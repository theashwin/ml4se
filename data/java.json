[
    {
        "label": "CdcSourcePcomplete",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/extensions/cdc-debezium/src/main/java/com/hazelcast/jet/cdc/impl/CdcSourceP.java",
        "code": "public boolean complete() {\n        if (!emitFromTraverser(traverser)) {\n            return false;\n        }\n        if (reconnectTracker.needsToWait()) {\n            return false;\n        }\n        if (!isConnectionUp()) {\n            return false;\n        }\n        if (snapshotInProgress) {\n            return false;\n        }\n\n        try {\n            if (!snapshotting && commitPeriod > 0) {\n                long currentTime = System.nanoTime();\n                if (currentTime - lastCommitTime > commitPeriod) {\n                    task.commit();\n                    lastCommitTime = currentTime;\n                }\n            }\n\n            List<SourceRecord> records = task.poll();\n            if (records == null || records.isEmpty()) {\n                traverser = eventTimeMapper.flatMapIdle();\n                emitFromTraverser(traverser);\n                return false;\n            }\n\n            for (SourceRecord record : records) {\n                Map<String, ?> partition = record.sourcePartition();\n                Map<String, ?> offset = record.sourceOffset();\n                state.setOffset(partition, offset);\n                task.commitRecord(record, null);\n            }\n\n            if (!snapshotting && commitPeriod == 0) {\n                task.commit();\n            }\n\n            traverser = Traversers.traverseIterable(records)\n                    .flatMap(record -> {\n                        T t = map(record);\n                        return t == null ? Traversers.empty() :\n                                eventTimeMapper.flatMapEvent(t, 0, extractTimestamp(record));\n                    });\n            emitFromTraverser(traverser);\n        } catch (InterruptedException ie) {\n            logger.warning(\"Interrupted while waiting for data\");\n            Thread.currentThread().interrupt();\n        } catch (RuntimeException re) {\n            reconnect(re);\n        }\n\n        return false;\n    }"
    },
    {
        "label": "CdcSourcePextractTimestamp",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/extensions/cdc-debezium/src/main/java/com/hazelcast/jet/cdc/impl/CdcSourceP.java",
        "code": "private static long extractTimestamp(SourceRecord sourceRecord) {\n        Schema valueSchema = sourceRecord.valueSchema();\n        boolean noValueTsMs = valueSchema.field(TIMESTAMP_MS_FIELD_NAME) == null;\n        boolean noSourceTsMs = valueSchema.field(\"source\").schema().field(TIMESTAMP_MS_FIELD_NAME) == null;\n        if (noValueTsMs && noSourceTsMs) {\n            return NO_NATIVE_TIME;\n        }\n        Long timestamp;\n        Struct valueStruct = (Struct) sourceRecord.value();\n        if (noValueTsMs) {\n            timestamp = valueStruct.getStruct(\"source\").getInt64(\"ts_ms\");\n        } else {\n            timestamp = valueStruct.getInt64(\"ts_ms\");\n        }\n        return timestamp == null ? NO_NATIVE_TIME : timestamp;\n    }"
    },
    {
        "label": "CdcSourcePgetCause",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/extensions/cdc-debezium/src/main/java/com/hazelcast/jet/cdc/impl/CdcSourceP.java",
        "code": "private static String getCause(Exception e) {\n        StringBuilder sb = new StringBuilder();\n        if (e.getMessage() != null) {\n            sb.append(\": \").append(e.getMessage());\n        }\n        if (e.getCause() != null && e.getCause().getMessage() != null) {\n            sb.append(\": \").append(e.getCause().getMessage());\n        }\n        return sb.toString();\n    }"
    },
    {
        "label": "CdcSourcePhandleConnectException",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/extensions/cdc-debezium/src/main/java/com/hazelcast/jet/cdc/impl/CdcSourceP.java",
        "code": "private void handleConnectException(RuntimeException ce) {\n        reconnectTracker.attemptFailed();\n        if (reconnectTracker.shouldTryAgain()) {\n            long waitTimeMs = reconnectTracker.getNextWaitTimeMs();\n            logger.warning(\"Failed to initialize the connector task, retrying in \" + waitTimeMs + \"ms\" + getCause(ce));\n        } else {\n            throw shutDownAndThrow(new JetException(\"Failed to connect to database\", peel(ce)));\n        }\n    }"
    },
    {
        "label": "CdcSourcePinit",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/extensions/cdc-debezium/src/main/java/com/hazelcast/jet/cdc/impl/CdcSourceP.java",
        "code": "protected void init(@Nonnull Context context) {\n        // workaround for https://github.com/hazelcast/hazelcast-jet/issues/2603\n        DriverManager.getDrivers();\n\n        String name = getName(properties);\n        this.logger = context.logger();\n\n        RetryStrategy retryStrategy = getRetryStrategy(properties);\n        log(logger, name, \"retry strategy\", retryStrategy);\n        this.reconnectTracker = new RetryTracker(retryStrategy);\n\n        snapshotting = !NONE.equals(context.processingGuarantee());\n        if (!snapshotting) {\n            this.commitPeriod = getCommitPeriod(properties);\n            log(logger, name, \"commit period\", commitPeriod);\n            if (commitPeriod > 0) {\n                lastCommitTime = System.nanoTime();\n            }\n        }\n\n        this.clearStateOnReconnect = getClearStateOnReconnect(properties);\n        log(logger, name, \"clear state on reconnect\", clearStateOnReconnect);\n    }"
    },
    {
        "label": "CdcSourcePisConnectionUp",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/extensions/cdc-debezium/src/main/java/com/hazelcast/jet/cdc/impl/CdcSourceP.java",
        "code": "private boolean isConnectionUp() {\n        try {\n            if (connector == null) {\n                connector = startNewConnector();\n                taskConfig = connector.taskConfigs(1).get(0);\n            }\n            if (task == null) {\n                task = startNewTask();\n            }\n            reconnectTracker.reset();\n            return true;\n        } catch (JetException je) {\n            throw shutDownAndThrow(je);\n        } catch (RuntimeException re) {\n            handleConnectException(re);\n            return false;\n        }\n    }"
    },
    {
        "label": "CdcSourcePkillConnection",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/extensions/cdc-debezium/src/main/java/com/hazelcast/jet/cdc/impl/CdcSourceP.java",
        "code": "private void killConnection() {\n        if (task != null) {\n            task.stop();\n            task = null;\n        }\n        if (connector != null) {\n            connector.stop();\n            connector = null;\n        }\n    }"
    },
    {
        "label": "CdcSourcePlog",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/extensions/cdc-debezium/src/main/java/com/hazelcast/jet/cdc/impl/CdcSourceP.java",
        "code": "private static void log(ILogger logger, String name, String property, Object value) {\n        if (logger.isInfoEnabled()) {\n            logger.info(name + \" has '\" + property + \"' set to '\" + value + '\\'');\n        }\n    }"
    },
    {
        "label": "CdcSourcePreconnect",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/extensions/cdc-debezium/src/main/java/com/hazelcast/jet/cdc/impl/CdcSourceP.java",
        "code": "private void reconnect(RuntimeException re) {\n        if (reconnectTracker.shouldTryAgain()) {\n            logger.warning(\"Connection to database lost, will attempt to reconnect and retry operations from \" +\n                    \"scratch\" + getCause(re), re);\n\n            killConnection();\n            reconnectTracker.reset();\n            if (clearStateOnReconnect) {\n                state = new State();\n            }\n        } else {\n            throw shutDownAndThrow(new JetException(\"Failed to connect to database\", peel(re)));\n        }\n    }"
    },
    {
        "label": "CdcSourcePrestoreFromSnapshot",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/extensions/cdc-debezium/src/main/java/com/hazelcast/jet/cdc/impl/CdcSourceP.java",
        "code": "protected void restoreFromSnapshot(@Nonnull Object key, @Nonnull Object value) {\n        if (!SNAPSHOT_KEY.equals(key)) {\n            throw new RuntimeException(\"Unexpected key received from snapshot: \" + key);\n        }\n        state = (State) value;\n    }"
    },
    {
        "label": "CdcSourcePsaveToSnapshot",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/extensions/cdc-debezium/src/main/java/com/hazelcast/jet/cdc/impl/CdcSourceP.java",
        "code": "public boolean saveToSnapshot() {\n        if (!emitFromTraverser(traverser)) {\n            return false;\n        }\n        snapshotInProgress = true;\n        if (snapshotTraverser == null) {\n            snapshotTraverser = Traversers.singleton(entry(SNAPSHOT_KEY, state))\n                    .onFirstNull(() -> {\n                        snapshotTraverser = null;\n                        getLogger().finest(\"Finished saving snapshot.\");\n                    });\n        }\n        return emitFromTraverserToSnapshot(snapshotTraverser);\n    }"
    },
    {
        "label": "CdcSourcePsnapshotCommitFinish",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/extensions/cdc-debezium/src/main/java/com/hazelcast/jet/cdc/impl/CdcSourceP.java",
        "code": "public boolean snapshotCommitFinish(boolean success) {\n        if (success && task != null) {\n            try {\n                task.commit();\n            } catch (InterruptedException e) {\n                logger.warning(\"Interrupted while committing\");\n                Thread.currentThread().interrupt();\n            }\n        }\n        snapshotInProgress = false;\n        return true;\n    }"
    },
    {
        "label": "HazelcastManifestTransformerbuildDefinition",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/hazelcast-build-utils/src/main/java/com/hazelcast/buildutils/HazelcastManifestTransformer.java",
        "code": "String buildDefinition(boolean addResolutionConstraint) {\n            StringBuilder sb = new StringBuilder(packageName);\n            if (addResolutionConstraint && resolutionOptional) {\n                sb.append(\";\").append(RESOLUTION_PREFIX).append(\"optional\");\n            }\n            if (version != null) {\n                sb.append(\";\").append(VERSION_PREFIX).append(version);\n            }\n            if (uses != null && !uses.isEmpty()) {\n                sb.append(\";\").append(USES_PREFIX).append('\"').append(join(uses.iterator(), \",\")).append('\"');\n            }\n            return sb.toString();\n        }"
    },
    {
        "label": "HazelcastManifestTransformerequals",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/hazelcast-build-utils/src/main/java/com/hazelcast/buildutils/HazelcastManifestTransformer.java",
        "code": "public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            PackageDefinition that = (PackageDefinition) o;\n            return Objects.equals(packageName, that.packageName);\n        }"
    },
    {
        "label": "HazelcastManifestTransformerfindResolutionConstraint",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/hazelcast-build-utils/src/main/java/com/hazelcast/buildutils/HazelcastManifestTransformer.java",
        "code": "private boolean findResolutionConstraint(String[] tokens) {\n            for (String token : tokens) {\n                if (token.startsWith(RESOLUTION_PREFIX)) {\n                    return token.toLowerCase(Locale.ROOT).equals(\"resolution:=optional\");\n                }\n            }\n            return false;\n        }"
    },
    {
        "label": "HazelcastManifestTransformerfindStrongerDefinition",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/hazelcast-build-utils/src/main/java/com/hazelcast/buildutils/HazelcastManifestTransformer.java",
        "code": "private PackageDefinition findStrongerDefinition(PackageDefinition packageDefinition,\n                                                     PackageDefinition oldPackageDefinition) {\n        // if the override is a remove instruction skip all other tests\n        if (packageDefinition.removeImport) {\n            return packageDefinition;\n        }\n\n        // if no old definition or new definition is required import we take the new one\n        if (oldPackageDefinition == null\n                || oldPackageDefinition.resolutionOptional && !packageDefinition.resolutionOptional) {\n            return packageDefinition;\n        }\n\n        // if old definition was required import but new isn't we take the old one\n        if (!oldPackageDefinition.resolutionOptional && packageDefinition.resolutionOptional) {\n            return oldPackageDefinition;\n        }\n\n        if (oldPackageDefinition.version == null && packageDefinition.version != null) {\n            return packageDefinition;\n        }\n\n        if (oldPackageDefinition.version != null && packageDefinition.version == null) {\n            return oldPackageDefinition;\n        }\n\n        return oldPackageDefinition;\n    }"
    },
    {
        "label": "HazelcastManifestTransformerfindUsesConstraint",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/hazelcast-build-utils/src/main/java/com/hazelcast/buildutils/HazelcastManifestTransformer.java",
        "code": "private Set<String> findUsesConstraint(String[] tokens) {\n            for (String token : tokens) {\n                if (token.startsWith(USES_PREFIX)) {\n                    String packages = token.substring(USES_OFFSET, token.length() - 1);\n                    String[] sepPackages = packages.split(\",\");\n                    return new LinkedHashSet<>(asList(sepPackages));\n                }\n            }\n            return emptySet();\n        }"
    },
    {
        "label": "HazelcastManifestTransformerfindVersionConstraint",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/hazelcast-build-utils/src/main/java/com/hazelcast/buildutils/HazelcastManifestTransformer.java",
        "code": "private String findVersionConstraint(String[] tokens) {\n            for (String token : tokens) {\n                if (token.startsWith(VERSION_PREFIX)) {\n                    return token.substring(VERSION_OFFSET);\n                }\n            }\n            return null;\n        }"
    },
    {
        "label": "HazelcastManifestTransformermergeExportUsesConstraint",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/hazelcast-build-utils/src/main/java/com/hazelcast/buildutils/HazelcastManifestTransformer.java",
        "code": "private PackageDefinition mergeExportUsesConstraint(PackageDefinition packageDefinition,\n                                                        PackageDefinition oldPackageDefinition) {\n        Set<String> uses = new LinkedHashSet<>();\n        if (oldPackageDefinition != null) {\n            uses.addAll(oldPackageDefinition.uses);\n        }\n        uses.addAll(packageDefinition.uses);\n\n        String packageName = packageDefinition.packageName;\n        boolean resolutionOptional = packageDefinition.resolutionOptional;\n        String version = packageDefinition.version;\n        return new PackageDefinition(packageName, resolutionOptional, version, uses);\n    }"
    },
    {
        "label": "HazelcastManifestTransformermodifyOutputStream",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/hazelcast-build-utils/src/main/java/com/hazelcast/buildutils/HazelcastManifestTransformer.java",
        "code": "public void modifyOutputStream(JarOutputStream jarOutputStream) throws IOException {\n        if (shadedManifest == null) {\n            shadedManifest = new Manifest();\n        }\n\n        Attributes attributes = shadedManifest.getMainAttributes();\n\n        if (overrideInstructions != null) {\n            precompileOverrideInstructions();\n            attributes.putValue(IMPORT_PACKAGE, join(shadeImports().iterator(), \",\"));\n            attributes.putValue(EXPORT_PACKAGE, join(shadeExports().iterator(), \",\"));\n        }\n\n        attributes.putValue(\"Created-By\", \"HazelcastManifestTransformer through Shade Plugin\");\n\n        if (mainClass != null) {\n            attributes.put(Attributes.Name.MAIN_CLASS, mainClass);\n        }\n\n        if (manifestEntries != null) {\n            for (Map.Entry<String, Object> entry : manifestEntries.entrySet()) {\n                attributes.put(new Attributes.Name(entry.getKey()), entry.getValue());\n            }\n        }\n\n        // the Manifest in hazelcast uberjar won't have the Automatic-Module-Name\n        attributes.remove(AUTOMATIC_MODULE_NAME);\n\n        jarOutputStream.putNextEntry(new JarEntry(JarFile.MANIFEST_NAME));\n        shadedManifest.write(jarOutputStream);\n        jarOutputStream.flush();\n    }"
    },
    {
        "label": "HazelcastManifestTransformeroverridePackageDefinitionResolution",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/hazelcast-build-utils/src/main/java/com/hazelcast/buildutils/HazelcastManifestTransformer.java",
        "code": "private PackageDefinition overridePackageDefinitionResolution(PackageDefinition packageDefinition) {\n        for (InstructionDefinition instructionDefinition : importOverrideInstructions) {\n            Instruction instruction = instructionDefinition.instruction;\n            if (instruction.matches(packageDefinition.packageName)) {\n                // is remove instruction?\n                if (instruction.isNegated()) {\n                    LOGGER.fine(\"Instruction '\" + instruction + \"' -> package '\" + packageDefinition.packageName + \"'\");\n                    return null;\n                }\n\n                LOGGER.fine(\"Instruction '\" + instruction + \"' -> package '\" + packageDefinition.packageName + \"'\");\n\n                PackageDefinition override = instructionDefinition.packageDefinition;\n                String packageName = packageDefinition.packageName;\n                String version = packageDefinition.version;\n                Set<String> uses = packageDefinition.uses;\n                return new PackageDefinition(packageName, override.resolutionOptional, version, uses);\n            }\n        }\n\n        return packageDefinition;\n    }"
    },
    {
        "label": "HazelcastManifestTransformerprecompileOverrideInstructions",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/hazelcast-build-utils/src/main/java/com/hazelcast/buildutils/HazelcastManifestTransformer.java",
        "code": "private void precompileOverrideInstructions() {\n        String importPackageInstructions = overrideInstructions.get(IMPORT_PACKAGE);\n        if (importPackageInstructions != null) {\n            List<String> packageInstructions = ElementParser.parseDelimitedString(importPackageInstructions, ',', true);\n            for (String packageInstruction : packageInstructions) {\n                PackageDefinition packageDefinition = new PackageDefinition(packageInstruction);\n                Instruction instruction = Instruction.getPattern(packageDefinition.packageName);\n                LOGGER.fine(\"Compiled import instruction '\" + packageInstruction + \"' -> \" + instruction);\n                importOverrideInstructions.add(new InstructionDefinition(packageDefinition, instruction));\n            }\n        }\n        String exportPackageInstructions = overrideInstructions.get(EXPORT_PACKAGE);\n        if (exportPackageInstructions != null) {\n            List<String> packageInstructions = ElementParser.parseDelimitedString(exportPackageInstructions, ',', true);\n            for (String packageInstruction : packageInstructions) {\n                PackageDefinition packageDefinition = new PackageDefinition(packageInstruction);\n                Instruction instruction = Instruction.getPattern(packageDefinition.packageName);\n                LOGGER.fine(\"Compiled export instruction '\" + packageInstruction + \"' -> \" + instruction);\n                exportOverrideInstructions.add(new InstructionDefinition(packageDefinition, instruction));\n            }\n        }\n    }"
    },
    {
        "label": "HazelcastManifestTransformerprocessResource",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/hazelcast-build-utils/src/main/java/com/hazelcast/buildutils/HazelcastManifestTransformer.java",
        "code": "public void processResource(String resource, InputStream inputStream, List<Relocator> relocators, long time)\n            throws IOException {\n        Attributes attributes;\n        if (shadedManifest == null) {\n            shadedManifest = new Manifest(inputStream);\n            attributes = shadedManifest.getMainAttributes();\n        } else {\n            Manifest manifest = new Manifest(inputStream);\n            attributes = manifest.getMainAttributes();\n        }\n\n        String importPackages = attributes.getValue(IMPORT_PACKAGE);\n        if (importPackages != null) {\n            List<String> definitions = ElementParser.parseDelimitedString(importPackages, ',', true);\n            for (String definition : definitions) {\n                PackageDefinition packageDefinition = new PackageDefinition(definition);\n\n                String packageName = packageDefinition.packageName;\n                PackageDefinition oldPackageDefinition = importedPackages.get(packageName);\n                importedPackages.put(packageName, findStrongerDefinition(packageDefinition, oldPackageDefinition));\n            }\n        }\n\n        String exportPackages = attributes.getValue(EXPORT_PACKAGE);\n        if (exportPackages != null) {\n            List<String> definitions = ElementParser.parseDelimitedString(exportPackages, ',', true);\n            for (String definition : definitions) {\n                PackageDefinition packageDefinition = new PackageDefinition(definition);\n\n                String packageName = packageDefinition.packageName;\n                PackageDefinition oldPackageDefinition = exportedPackages.get(packageName);\n                exportedPackages.put(packageName, mergeExportUsesConstraint(packageDefinition, oldPackageDefinition));\n            }\n        }\n\n        close(inputStream);\n    }"
    },
    {
        "label": "HazelcastManifestTransformershadeImports",
        "githubFileLink": "https://github.com/hazelcast/hazelcast/blob/master/hazelcast-build-utils/src/main/java/com/hazelcast/buildutils/HazelcastManifestTransformer.java",
        "code": "private Set<String> shadeImports() {\n        for (String export : exportedPackages.keySet()) {\n            PackageDefinition definition = new PackageDefinition(export);\n            importedPackages.remove(definition.packageName);\n        }\n        Set<String> imports = new LinkedHashSet<>();\n        for (Map.Entry<String, PackageDefinition> entry : importedPackages.entrySet()) {\n            PackageDefinition original = entry.getValue();\n            PackageDefinition overridden = overridePackageDefinitionResolution(original);\n            if (overridden != null) {\n                String definition = overridden.buildDefinition(true);\n                imports.add(definition);\n                LOGGER.fine(\"Adding shaded import -> \" + definition);\n            } else {\n                LOGGER.fine(\"Removing shaded import -> \" + entry.getValue().packageName);\n            }\n        }\n        return imports;\n    }"
    }
]