[{"code": "private static BitMatrix extractPureBits(BitMatrix image) throws NotFoundException {\n\n    int[] enclosingRectangle = image.getEnclosingRectangle();\n    if (enclosingRectangle == null) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n\n    int left = enclosingRectangle[0];\n    int top = enclosingRectangle[1];\n    int width = enclosingRectangle[2];\n    int height = enclosingRectangle[3];\n\n    // Now just read off the bits\n    BitMatrix bits = new BitMatrix(MATRIX_WIDTH, MATRIX_HEIGHT);\n    for (int y = 0; y < MATRIX_HEIGHT; y++) {\n      int iy = top + (y * height + height / 2) / MATRIX_HEIGHT;\n      for (int x = 0; x < MATRIX_WIDTH; x++) {\n        int ix = left + (x * width + width / 2 + (y & 0x01) *  width / 2) / MATRIX_WIDTH;\n        if (image.get(ix, iy)) {\n          bits.set(x, y);\n        }\n      }\n    }\n    return bits;\n  }", "code_tokens": ["private", "static", "BitMatrix", "extractPureBits", "(", "BitMatrix", "image", ")", "throws", "NotFoundException", "{", "int", "[", "]", "enclosingRectangle", "=", "image", ".", "getEnclosingRectangle", "(", ")", ";", "if", "(", "enclosingRectangle", "==", "null", ")", "{", "throw", "NotFoundException", ".", "getNotFoundInstance", "(", ")", ";", "}", "int", "left", "=", "enclosingRectangle", "[", "0", "]", ";", "int", "top", "=", "enclosingRectangle", "[", "1", "]", ";", "int", "width", "=", "enclosingRectangle", "[", "2", "]", ";", "int", "height", "=", "enclosingRectangle", "[", "3", "]", ";", "// Now just read off the bits", "BitMatrix", "bits", "=", "new", "BitMatrix", "(", "MATRIX_WIDTH", ",", "MATRIX_HEIGHT", ")", ";", "for", "(", "int", "y", "=", "0", ";", "y", "<", "MATRIX_HEIGHT", ";", "y", "++", ")", "{", "int", "iy", "=", "top", "+", "(", "y", "*", "height", "+", "height", "/", "2", ")", "/", "MATRIX_HEIGHT", ";", "for", "(", "int", "x", "=", "0", ";", "x", "<", "MATRIX_WIDTH", ";", "x", "++", ")", "{", "int", "ix", "=", "left", "+", "(", "x", "*", "width", "+", "width", "/", "2", "+", "(", "y", "&", "0x01", ")", "*", "width", "/", "2", ")", "/", "MATRIX_WIDTH", ";", "if", "(", "image", ".", "get", "(", "ix", ",", "iy", ")", ")", "{", "bits", ".", "set", "(", "x", ",", "y", ")", ";", "}", "}", "}", "return", "bits", ";", "}"], "original_string": "private static BitMatrix extractPureBits(BitMatrix image) throws NotFoundException {\n\n    int[] enclosingRectangle = image.getEnclosingRectangle();\n    if (enclosingRectangle == null) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n\n    int left = enclosingRectangle[0];\n    int top = enclosingRectangle[1];\n    int width = enclosingRectangle[2];\n    int height = enclosingRectangle[3];\n\n    // Now just read off the bits\n    BitMatrix bits = new BitMatrix(MATRIX_WIDTH, MATRIX_HEIGHT);\n    for (int y = 0; y < MATRIX_HEIGHT; y++) {\n      int iy = top + (y * height + height / 2) / MATRIX_HEIGHT;\n      for (int x = 0; x < MATRIX_WIDTH; x++) {\n        int ix = left + (x * width + width / 2 + (y & 0x01) *  width / 2) / MATRIX_WIDTH;\n        if (image.get(ix, iy)) {\n          bits.set(x, y);\n        }\n      }\n    }\n    return bits;\n  }"}, {"code": "public static boolean cleanDirectory(File dir) {\n        if (dir.isDirectory()) {\n            String[] children = dir.list();\n            if (children != null) {\n                for (String aChildren : children) {\n                    boolean success = cleanDirectory(new File(dir, aChildren));\n                    if (!success) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return dir.delete();\n    }", "code_tokens": ["public", "static", "boolean", "cleanDirectory", "(", "File", "dir", ")", "{", "if", "(", "dir", ".", "isDirectory", "(", ")", ")", "{", "String", "[", "]", "children", "=", "dir", ".", "list", "(", ")", ";", "if", "(", "children", "!=", "null", ")", "{", "for", "(", "String", "aChildren", ":", "children", ")", "{", "boolean", "success", "=", "cleanDirectory", "(", "new", "File", "(", "dir", ",", "aChildren", ")", ")", ";", "if", "(", "!", "success", ")", "{", "return", "false", ";", "}", "}", "}", "}", "return", "dir", ".", "delete", "(", ")", ";", "}"], "original_string": "public static boolean cleanDirectory(File dir) {\n        if (dir.isDirectory()) {\n            String[] children = dir.list();\n            if (children != null) {\n                for (String aChildren : children) {\n                    boolean success = cleanDirectory(new File(dir, aChildren));\n                    if (!success) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return dir.delete();\n    }"}, {"code": "public boolean isApplicable(Class<? extends T> targetType) {\n        Class<? extends T> applicable = Functions.getTypeParameter(clazz,getP(),0);\n        return applicable.isAssignableFrom(targetType);\n    }", "code_tokens": ["public", "boolean", "isApplicable", "(", "Class", "<", "?", "extends", "T", ">", "targetType", ")", "{", "Class", "<", "?", "extends", "T", ">", "applicable", "=", "Functions", ".", "getTypeParameter", "(", "clazz", ",", "getP", "(", ")", ",", "0", ")", ";", "return", "applicable", ".", "isAssignableFrom", "(", "targetType", ")", ";", "}"], "original_string": "public boolean isApplicable(Class<? extends T> targetType) {\n        Class<? extends T> applicable = Functions.getTypeParameter(clazz,getP(),0);\n        return applicable.isAssignableFrom(targetType);\n    }"}, {"code": "public void prependActionsToActionStateExecutionList(final Flow flow, final String actionStateId, final EvaluateAction... actions) {\n        addActionsToActionStateExecutionListAt(flow, actionStateId, 0, actions);\n    }", "code_tokens": ["public", "void", "prependActionsToActionStateExecutionList", "(", "final", "Flow", "flow", ",", "final", "String", "actionStateId", ",", "final", "EvaluateAction", "...", "actions", ")", "{", "addActionsToActionStateExecutionListAt", "(", "flow", ",", "actionStateId", ",", "0", ",", "actions", ")", ";", "}"], "original_string": "public void prependActionsToActionStateExecutionList(final Flow flow, final String actionStateId, final EvaluateAction... actions) {\n        addActionsToActionStateExecutionListAt(flow, actionStateId, 0, actions);\n    }"}, {"code": "protected final long nextScheduledTaskNano() {\n        Queue<ScheduledFutureTask<?>> scheduledTaskQueue = this.scheduledTaskQueue;\n        ScheduledFutureTask<?> scheduledTask = scheduledTaskQueue == null ? null : scheduledTaskQueue.peek();\n        if (scheduledTask == null) {\n            return -1;\n        }\n        return Math.max(0, scheduledTask.deadlineNanos() - nanoTime());\n    }", "code_tokens": ["protected", "final", "long", "nextScheduledTaskNano", "(", ")", "{", "Queue", "<", "ScheduledFutureTask", "<", "?", ">", ">", "scheduledTaskQueue", "=", "this", ".", "scheduledTaskQueue", ";", "ScheduledFutureTask", "<", "?", ">", "scheduledTask", "=", "scheduledTaskQueue", "==", "null", "?", "null", ":", "scheduledTaskQueue", ".", "peek", "(", ")", ";", "if", "(", "scheduledTask", "==", "null", ")", "{", "return", "-", "1", ";", "}", "return", "Math", ".", "max", "(", "0", ",", "scheduledTask", ".", "deadlineNanos", "(", ")", "-", "nanoTime", "(", ")", ")", ";", "}"], "original_string": "protected final long nextScheduledTaskNano() {\n        Queue<ScheduledFutureTask<?>> scheduledTaskQueue = this.scheduledTaskQueue;\n        ScheduledFutureTask<?> scheduledTask = scheduledTaskQueue == null ? null : scheduledTaskQueue.peek();\n        if (scheduledTask == null) {\n            return -1;\n        }\n        return Math.max(0, scheduledTask.deadlineNanos() - nanoTime());\n    }"}, {"code": "public StyleSet setBackgroundColor(IndexedColors backgroundColor, boolean withHeadCell) {\r\n\t\tif (withHeadCell) {\r\n\t\t\tStyleUtil.setColor(this.headCellStyle, backgroundColor, FillPatternType.SOLID_FOREGROUND);\r\n\t\t}\r\n\t\tStyleUtil.setColor(this.cellStyle, backgroundColor, FillPatternType.SOLID_FOREGROUND);\r\n\t\tStyleUtil.setColor(this.cellStyleForNumber, backgroundColor, FillPatternType.SOLID_FOREGROUND);\r\n\t\tStyleUtil.setColor(this.cellStyleForDate, backgroundColor, FillPatternType.SOLID_FOREGROUND);\r\n\t\treturn this;\r\n\t}", "code_tokens": ["public", "StyleSet", "setBackgroundColor", "(", "IndexedColors", "backgroundColor", ",", "boolean", "withHeadCell", ")", "{", "if", "(", "withHeadCell", ")", "{", "StyleUtil", ".", "setColor", "(", "this", ".", "headCellStyle", ",", "backgroundColor", ",", "FillPatternType", ".", "SOLID_FOREGROUND", ")", ";", "}", "StyleUtil", ".", "setColor", "(", "this", ".", "cellStyle", ",", "backgroundColor", ",", "FillPatternType", ".", "SOLID_FOREGROUND", ")", ";", "StyleUtil", ".", "setColor", "(", "this", ".", "cellStyleForNumber", ",", "backgroundColor", ",", "FillPatternType", ".", "SOLID_FOREGROUND", ")", ";", "StyleUtil", ".", "setColor", "(", "this", ".", "cellStyleForDate", ",", "backgroundColor", ",", "FillPatternType", ".", "SOLID_FOREGROUND", ")", ";", "return", "this", ";", "}"], "original_string": "public StyleSet setBackgroundColor(IndexedColors backgroundColor, boolean withHeadCell) {\r\n\t\tif (withHeadCell) {\r\n\t\t\tStyleUtil.setColor(this.headCellStyle, backgroundColor, FillPatternType.SOLID_FOREGROUND);\r\n\t\t}\r\n\t\tStyleUtil.setColor(this.cellStyle, backgroundColor, FillPatternType.SOLID_FOREGROUND);\r\n\t\tStyleUtil.setColor(this.cellStyleForNumber, backgroundColor, FillPatternType.SOLID_FOREGROUND);\r\n\t\tStyleUtil.setColor(this.cellStyleForDate, backgroundColor, FillPatternType.SOLID_FOREGROUND);\r\n\t\treturn this;\r\n\t}"}, {"code": "public DataNode getDataNode(final String logicTableName) {\n        TableRule tableRule = getTableRule(logicTableName);\n        return tableRule.getActualDataNodes().get(0);\n    }", "code_tokens": ["public", "DataNode", "getDataNode", "(", "final", "String", "logicTableName", ")", "{", "TableRule", "tableRule", "=", "getTableRule", "(", "logicTableName", ")", ";", "return", "tableRule", ".", "getActualDataNodes", "(", ")", ".", "get", "(", "0", ")", ";", "}"], "original_string": "public DataNode getDataNode(final String logicTableName) {\n        TableRule tableRule = getTableRule(logicTableName);\n        return tableRule.getActualDataNodes().get(0);\n    }"}, {"code": "private boolean[] extractBits(BitMatrix matrix) {\n    boolean compact = ddata.isCompact();\n    int layers = ddata.getNbLayers();\n    int baseMatrixSize = (compact ? 11 : 14) + layers * 4; // not including alignment lines\n    int[] alignmentMap = new int[baseMatrixSize];\n    boolean[] rawbits = new boolean[totalBitsInLayer(layers, compact)];\n\n    if (compact) {\n      for (int i = 0; i < alignmentMap.length; i++) {\n        alignmentMap[i] = i;\n      }\n    } else {\n      int matrixSize = baseMatrixSize + 1 + 2 * ((baseMatrixSize / 2 - 1) / 15);\n      int origCenter = baseMatrixSize / 2;\n      int center = matrixSize / 2;\n      for (int i = 0; i < origCenter; i++) {\n        int newOffset = i + i / 15;\n        alignmentMap[origCenter - i - 1] = center - newOffset - 1;\n        alignmentMap[origCenter + i] = center + newOffset + 1;\n      }\n    }\n    for (int i = 0, rowOffset = 0; i < layers; i++) {\n      int rowSize = (layers - i) * 4 + (compact ? 9 : 12);\n      // The top-left most point of this layer is <low, low> (not including alignment lines)\n      int low = i * 2;\n      // The bottom-right most point of this layer is <high, high> (not including alignment lines)\n      int high = baseMatrixSize - 1 - low;\n      // We pull bits from the two 2 x rowSize columns and two rowSize x 2 rows\n      for (int j = 0; j < rowSize; j++) {\n        int columnOffset = j * 2;\n        for (int k = 0; k < 2; k++) {\n          // left column\n          rawbits[rowOffset + columnOffset + k] =\n              matrix.get(alignmentMap[low + k], alignmentMap[low + j]);\n          // bottom row\n          rawbits[rowOffset + 2 * rowSize + columnOffset + k] =\n              matrix.get(alignmentMap[low + j], alignmentMap[high - k]);\n          // right column\n          rawbits[rowOffset + 4 * rowSize + columnOffset + k] =\n              matrix.get(alignmentMap[high - k], alignmentMap[high - j]);\n          // top row\n          rawbits[rowOffset + 6 * rowSize + columnOffset + k] =\n              matrix.get(alignmentMap[high - j], alignmentMap[low + k]);\n        }\n      }\n      rowOffset += rowSize * 8;\n    }\n    return rawbits;\n  }", "code_tokens": ["private", "boolean", "[", "]", "extractBits", "(", "BitMatrix", "matrix", ")", "{", "boolean", "compact", "=", "ddata", ".", "isCompact", "(", ")", ";", "int", "layers", "=", "ddata", ".", "getNbLayers", "(", ")", ";", "int", "baseMatrixSize", "=", "(", "compact", "?", "11", ":", "14", ")", "+", "layers", "*", "4", ";", "// not including alignment lines", "int", "[", "]", "alignmentMap", "=", "new", "int", "[", "baseMatrixSize", "]", ";", "boolean", "[", "]", "rawbits", "=", "new", "boolean", "[", "totalBitsInLayer", "(", "layers", ",", "compact", ")", "]", ";", "if", "(", "compact", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "alignmentMap", ".", "length", ";", "i", "++", ")", "{", "alignmentMap", "[", "i", "]", "=", "i", ";", "}", "}", "else", "{", "int", "matrixSize", "=", "baseMatrixSize", "+", "1", "+", "2", "*", "(", "(", "baseMatrixSize", "/", "2", "-", "1", ")", "/", "15", ")", ";", "int", "origCenter", "=", "baseMatrixSize", "/", "2", ";", "int", "center", "=", "matrixSize", "/", "2", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "origCenter", ";", "i", "++", ")", "{", "int", "newOffset", "=", "i", "+", "i", "/", "15", ";", "alignmentMap", "[", "origCenter", "-", "i", "-", "1", "]", "=", "center", "-", "newOffset", "-", "1", ";", "alignmentMap", "[", "origCenter", "+", "i", "]", "=", "center", "+", "newOffset", "+", "1", ";", "}", "}", "for", "(", "int", "i", "=", "0", ",", "rowOffset", "=", "0", ";", "i", "<", "layers", ";", "i", "++", ")", "{", "int", "rowSize", "=", "(", "layers", "-", "i", ")", "*", "4", "+", "(", "compact", "?", "9", ":", "12", ")", ";", "// The top-left most point of this layer is <low, low> (not including alignment lines)", "int", "low", "=", "i", "*", "2", ";", "// The bottom-right most point of this layer is <high, high> (not including alignment lines)", "int", "high", "=", "baseMatrixSize", "-", "1", "-", "low", ";", "// We pull bits from the two 2 x rowSize columns and two rowSize x 2 rows", "for", "(", "int", "j", "=", "0", ";", "j", "<", "rowSize", ";", "j", "++", ")", "{", "int", "columnOffset", "=", "j", "*", "2", ";", "for", "(", "int", "k", "=", "0", ";", "k", "<", "2", ";", "k", "++", ")", "{", "// left column", "rawbits", "[", "rowOffset", "+", "columnOffset", "+", "k", "]", "=", "matrix", ".", "get", "(", "alignmentMap", "[", "low", "+", "k", "]", ",", "alignmentMap", "[", "low", "+", "j", "]", ")", ";", "// bottom row", "rawbits", "[", "rowOffset", "+", "2", "*", "rowSize", "+", "columnOffset", "+", "k", "]", "=", "matrix", ".", "get", "(", "alignmentMap", "[", "low", "+", "j", "]", ",", "alignmentMap", "[", "high", "-", "k", "]", ")", ";", "// right column", "rawbits", "[", "rowOffset", "+", "4", "*", "rowSize", "+", "columnOffset", "+", "k", "]", "=", "matrix", ".", "get", "(", "alignmentMap", "[", "high", "-", "k", "]", ",", "alignmentMap", "[", "high", "-", "j", "]", ")", ";", "// top row", "rawbits", "[", "rowOffset", "+", "6", "*", "rowSize", "+", "columnOffset", "+", "k", "]", "=", "matrix", ".", "get", "(", "alignmentMap", "[", "high", "-", "j", "]", ",", "alignmentMap", "[", "low", "+", "k", "]", ")", ";", "}", "}", "rowOffset", "+=", "rowSize", "*", "8", ";", "}", "return", "rawbits", ";", "}"], "original_string": "private boolean[] extractBits(BitMatrix matrix) {\n    boolean compact = ddata.isCompact();\n    int layers = ddata.getNbLayers();\n    int baseMatrixSize = (compact ? 11 : 14) + layers * 4; // not including alignment lines\n    int[] alignmentMap = new int[baseMatrixSize];\n    boolean[] rawbits = new boolean[totalBitsInLayer(layers, compact)];\n\n    if (compact) {\n      for (int i = 0; i < alignmentMap.length; i++) {\n        alignmentMap[i] = i;\n      }\n    } else {\n      int matrixSize = baseMatrixSize + 1 + 2 * ((baseMatrixSize / 2 - 1) / 15);\n      int origCenter = baseMatrixSize / 2;\n      int center = matrixSize / 2;\n      for (int i = 0; i < origCenter; i++) {\n        int newOffset = i + i / 15;\n        alignmentMap[origCenter - i - 1] = center - newOffset - 1;\n        alignmentMap[origCenter + i] = center + newOffset + 1;\n      }\n    }\n    for (int i = 0, rowOffset = 0; i < layers; i++) {\n      int rowSize = (layers - i) * 4 + (compact ? 9 : 12);\n      // The top-left most point of this layer is <low, low> (not including alignment lines)\n      int low = i * 2;\n      // The bottom-right most point of this layer is <high, high> (not including alignment lines)\n      int high = baseMatrixSize - 1 - low;\n      // We pull bits from the two 2 x rowSize columns and two rowSize x 2 rows\n      for (int j = 0; j < rowSize; j++) {\n        int columnOffset = j * 2;\n        for (int k = 0; k < 2; k++) {\n          // left column\n          rawbits[rowOffset + columnOffset + k] =\n              matrix.get(alignmentMap[low + k], alignmentMap[low + j]);\n          // bottom row\n          rawbits[rowOffset + 2 * rowSize + columnOffset + k] =\n              matrix.get(alignmentMap[low + j], alignmentMap[high - k]);\n          // right column\n          rawbits[rowOffset + 4 * rowSize + columnOffset + k] =\n              matrix.get(alignmentMap[high - k], alignmentMap[high - j]);\n          // top row\n          rawbits[rowOffset + 6 * rowSize + columnOffset + k] =\n              matrix.get(alignmentMap[high - j], alignmentMap[low + k]);\n        }\n      }\n      rowOffset += rowSize * 8;\n    }\n    return rawbits;\n  }"}, {"code": "@Override\n    @JsonIgnore\n    public String getId() {\n        if (instanceId != null && !instanceId.isEmpty()) {\n            return instanceId;\n        } else if (dataCenterInfo instanceof AmazonInfo) {\n            String uniqueId = ((AmazonInfo) dataCenterInfo).getId();\n            if (uniqueId != null && !uniqueId.isEmpty()) {\n                return uniqueId;\n            }\n        }\n        return hostName;\n    }", "code_tokens": ["@", "Override", "@", "JsonIgnore", "public", "String", "getId", "(", ")", "{", "if", "(", "instanceId", "!=", "null", "&&", "!", "instanceId", ".", "isEmpty", "(", ")", ")", "{", "return", "instanceId", ";", "}", "else", "if", "(", "dataCenterInfo", "instanceof", "AmazonInfo", ")", "{", "String", "uniqueId", "=", "(", "(", "AmazonInfo", ")", "dataCenterInfo", ")", ".", "getId", "(", ")", ";", "if", "(", "uniqueId", "!=", "null", "&&", "!", "uniqueId", ".", "isEmpty", "(", ")", ")", "{", "return", "uniqueId", ";", "}", "}", "return", "hostName", ";", "}"], "original_string": "@Override\n    @JsonIgnore\n    public String getId() {\n        if (instanceId != null && !instanceId.isEmpty()) {\n            return instanceId;\n        } else if (dataCenterInfo instanceof AmazonInfo) {\n            String uniqueId = ((AmazonInfo) dataCenterInfo).getId();\n            if (uniqueId != null && !uniqueId.isEmpty()) {\n                return uniqueId;\n            }\n        }\n        return hostName;\n    }"}, {"code": "public double[] getColumnPackedCopy()\n    {\n        double[] vals = new double[m * n];\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                vals[i + j * m] = A[i][j];\n            }\n        }\n        return vals;\n    }", "code_tokens": ["public", "double", "[", "]", "getColumnPackedCopy", "(", ")", "{", "double", "[", "]", "vals", "=", "new", "double", "[", "m", "*", "n", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "m", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "0", ";", "j", "<", "n", ";", "j", "++", ")", "{", "vals", "[", "i", "+", "j", "*", "m", "]", "=", "A", "[", "i", "]", "[", "j", "]", ";", "}", "}", "return", "vals", ";", "}"], "original_string": "public double[] getColumnPackedCopy()\n    {\n        double[] vals = new double[m * n];\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                vals[i + j * m] = A[i][j];\n            }\n        }\n        return vals;\n    }"}, {"code": "public static void processWarmUpWeight(ProviderInfo providerInfo) {\n\n        String warmupTimeStr = providerInfo.getStaticAttr(ProviderInfoAttrs.ATTR_WARMUP_TIME);\n        String warmupWeightStr = providerInfo.getStaticAttr(ProviderInfoAttrs.ATTR_WARMUP_WEIGHT);\n        String startTimeStr = providerInfo.getStaticAttr(ProviderInfoAttrs.ATTR_START_TIME);\n\n        if (StringUtils.isNotBlank(warmupTimeStr) && StringUtils.isNotBlank(warmupWeightStr) &&\n            StringUtils.isNotBlank(startTimeStr)) {\n\n            long warmupTime = CommonUtils.parseLong(warmupTimeStr, 0);\n            int warmupWeight = CommonUtils.parseInt(warmupWeightStr,\n                Integer.parseInt(providerInfo.getStaticAttr(ProviderInfoAttrs.ATTR_WEIGHT)));\n            long startTime = CommonUtils.parseLong(startTimeStr, 0);\n            long warmupEndTime = startTime + warmupTime;\n\n            // set for dynamic\n            providerInfo.setDynamicAttr(ProviderInfoAttrs.ATTR_WARMUP_WEIGHT, warmupWeight);\n            providerInfo.setDynamicAttr(ProviderInfoAttrs.ATTR_WARM_UP_END_TIME, warmupEndTime);\n            providerInfo.setStatus(ProviderStatus.WARMING_UP);\n        }\n\n        // remove from static\n        providerInfo.getStaticAttrs().remove(ProviderInfoAttrs.ATTR_WARMUP_TIME);\n        providerInfo.getStaticAttrs().remove(ProviderInfoAttrs.ATTR_WARMUP_WEIGHT);\n\n    }", "code_tokens": ["public", "static", "void", "processWarmUpWeight", "(", "ProviderInfo", "providerInfo", ")", "{", "String", "warmupTimeStr", "=", "providerInfo", ".", "getStaticAttr", "(", "ProviderInfoAttrs", ".", "ATTR_WARMUP_TIME", ")", ";", "String", "warmupWeightStr", "=", "providerInfo", ".", "getStaticAttr", "(", "ProviderInfoAttrs", ".", "ATTR_WARMUP_WEIGHT", ")", ";", "String", "startTimeStr", "=", "providerInfo", ".", "getStaticAttr", "(", "ProviderInfoAttrs", ".", "ATTR_START_TIME", ")", ";", "if", "(", "StringUtils", ".", "isNotBlank", "(", "warmupTimeStr", ")", "&&", "StringUtils", ".", "isNotBlank", "(", "warmupWeightStr", ")", "&&", "StringUtils", ".", "isNotBlank", "(", "startTimeStr", ")", ")", "{", "long", "warmupTime", "=", "CommonUtils", ".", "parseLong", "(", "warmupTimeStr", ",", "0", ")", ";", "int", "warmupWeight", "=", "CommonUtils", ".", "parseInt", "(", "warmupWeightStr", ",", "Integer", ".", "parseInt", "(", "providerInfo", ".", "getStaticAttr", "(", "ProviderInfoAttrs", ".", "ATTR_WEIGHT", ")", ")", ")", ";", "long", "startTime", "=", "CommonUtils", ".", "parseLong", "(", "startTimeStr", ",", "0", ")", ";", "long", "warmupEndTime", "=", "startTime", "+", "warmupTime", ";", "// set for dynamic", "providerInfo", ".", "setDynamicAttr", "(", "ProviderInfoAttrs", ".", "ATTR_WARMUP_WEIGHT", ",", "warmupWeight", ")", ";", "providerInfo", ".", "setDynamicAttr", "(", "ProviderInfoAttrs", ".", "ATTR_WARM_UP_END_TIME", ",", "warmupEndTime", ")", ";", "providerInfo", ".", "setStatus", "(", "ProviderStatus", ".", "WARMING_UP", ")", ";", "}", "// remove from static", "providerInfo", ".", "getStaticAttrs", "(", ")", ".", "remove", "(", "ProviderInfoAttrs", ".", "ATTR_WARMUP_TIME", ")", ";", "providerInfo", ".", "getStaticAttrs", "(", ")", ".", "remove", "(", "ProviderInfoAttrs", ".", "ATTR_WARMUP_WEIGHT", ")", ";", "}"], "original_string": "public static void processWarmUpWeight(ProviderInfo providerInfo) {\n\n        String warmupTimeStr = providerInfo.getStaticAttr(ProviderInfoAttrs.ATTR_WARMUP_TIME);\n        String warmupWeightStr = providerInfo.getStaticAttr(ProviderInfoAttrs.ATTR_WARMUP_WEIGHT);\n        String startTimeStr = providerInfo.getStaticAttr(ProviderInfoAttrs.ATTR_START_TIME);\n\n        if (StringUtils.isNotBlank(warmupTimeStr) && StringUtils.isNotBlank(warmupWeightStr) &&\n            StringUtils.isNotBlank(startTimeStr)) {\n\n            long warmupTime = CommonUtils.parseLong(warmupTimeStr, 0);\n            int warmupWeight = CommonUtils.parseInt(warmupWeightStr,\n                Integer.parseInt(providerInfo.getStaticAttr(ProviderInfoAttrs.ATTR_WEIGHT)));\n            long startTime = CommonUtils.parseLong(startTimeStr, 0);\n            long warmupEndTime = startTime + warmupTime;\n\n            // set for dynamic\n            providerInfo.setDynamicAttr(ProviderInfoAttrs.ATTR_WARMUP_WEIGHT, warmupWeight);\n            providerInfo.setDynamicAttr(ProviderInfoAttrs.ATTR_WARM_UP_END_TIME, warmupEndTime);\n            providerInfo.setStatus(ProviderStatus.WARMING_UP);\n        }\n\n        // remove from static\n        providerInfo.getStaticAttrs().remove(ProviderInfoAttrs.ATTR_WARMUP_TIME);\n        providerInfo.getStaticAttrs().remove(ProviderInfoAttrs.ATTR_WARMUP_WEIGHT);\n\n    }"}, {"code": "public void setListeners(StatsStorageRouter statsStorage, Collection<? extends TrainingListener> listeners) {\n        //Check if we have any RoutingIterationListener instances that need a StatsStorage implementation...\n        if (listeners != null) {\n            for (TrainingListener l : listeners) {\n                if (l instanceof RoutingIterationListener) {\n                    RoutingIterationListener rl = (RoutingIterationListener) l;\n                    if (statsStorage == null && rl.getStorageRouter() == null) {\n                        log.warn(\"RoutingIterationListener provided without providing any StatsStorage instance. Iterator may not function without one. Listener: {}\",\n                                        l);\n                    }\n                }\n            }\n\n            this.listeners.addAll(listeners);\n        } else {\n            this.listeners.clear();\n        }\n\n        this.storageRouter = statsStorage;\n    }", "code_tokens": ["public", "void", "setListeners", "(", "StatsStorageRouter", "statsStorage", ",", "Collection", "<", "?", "extends", "TrainingListener", ">", "listeners", ")", "{", "//Check if we have any RoutingIterationListener instances that need a StatsStorage implementation...", "if", "(", "listeners", "!=", "null", ")", "{", "for", "(", "TrainingListener", "l", ":", "listeners", ")", "{", "if", "(", "l", "instanceof", "RoutingIterationListener", ")", "{", "RoutingIterationListener", "rl", "=", "(", "RoutingIterationListener", ")", "l", ";", "if", "(", "statsStorage", "==", "null", "&&", "rl", ".", "getStorageRouter", "(", ")", "==", "null", ")", "{", "log", ".", "warn", "(", "\"RoutingIterationListener provided without providing any StatsStorage instance. Iterator may not function without one. Listener: {}\"", ",", "l", ")", ";", "}", "}", "}", "this", ".", "listeners", ".", "addAll", "(", "listeners", ")", ";", "}", "else", "{", "this", ".", "listeners", ".", "clear", "(", ")", ";", "}", "this", ".", "storageRouter", "=", "statsStorage", ";", "}"], "original_string": "public void setListeners(StatsStorageRouter statsStorage, Collection<? extends TrainingListener> listeners) {\n        //Check if we have any RoutingIterationListener instances that need a StatsStorage implementation...\n        if (listeners != null) {\n            for (TrainingListener l : listeners) {\n                if (l instanceof RoutingIterationListener) {\n                    RoutingIterationListener rl = (RoutingIterationListener) l;\n                    if (statsStorage == null && rl.getStorageRouter() == null) {\n                        log.warn(\"RoutingIterationListener provided without providing any StatsStorage instance. Iterator may not function without one. Listener: {}\",\n                                        l);\n                    }\n                }\n            }\n\n            this.listeners.addAll(listeners);\n        } else {\n            this.listeners.clear();\n        }\n\n        this.storageRouter = statsStorage;\n    }"}, {"code": "public CouchDbConsentDecision findFirstConsentDecision(final String principal, final String service) {\n        val view = createQuery(\"by_consent_decision\").key(ComplexKey.of(principal, service)).limit(1).includeDocs(true);\n        return db.queryView(view, CouchDbConsentDecision.class).stream().findFirst().orElse(null);\n    }", "code_tokens": ["public", "CouchDbConsentDecision", "findFirstConsentDecision", "(", "final", "String", "principal", ",", "final", "String", "service", ")", "{", "val", "view", "=", "createQuery", "(", "\"by_consent_decision\"", ")", ".", "key", "(", "ComplexKey", ".", "of", "(", "principal", ",", "service", ")", ")", ".", "limit", "(", "1", ")", ".", "includeDocs", "(", "true", ")", ";", "return", "db", ".", "queryView", "(", "view", ",", "CouchDbConsentDecision", ".", "class", ")", ".", "stream", "(", ")", ".", "findFirst", "(", ")", ".", "orElse", "(", "null", ")", ";", "}"], "original_string": "public CouchDbConsentDecision findFirstConsentDecision(final String principal, final String service) {\n        val view = createQuery(\"by_consent_decision\").key(ComplexKey.of(principal, service)).limit(1).includeDocs(true);\n        return db.queryView(view, CouchDbConsentDecision.class).stream().findFirst().orElse(null);\n    }"}, {"code": "public static String getType(String fileStreamHexHead) {\r\n\t\tfor (Entry<String, String> fileTypeEntry : fileTypeMap.entrySet()) {\r\n\t\t\tif(StrUtil.startWithIgnoreCase(fileStreamHexHead, fileTypeEntry.getKey())) {\r\n\t\t\t\treturn fileTypeEntry.getValue();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}", "code_tokens": ["public", "static", "String", "getType", "(", "String", "fileStreamHexHead", ")", "{", "for", "(", "Entry", "<", "String", ",", "String", ">", "fileTypeEntry", ":", "fileTypeMap", ".", "entrySet", "(", ")", ")", "{", "if", "(", "StrUtil", ".", "startWithIgnoreCase", "(", "fileStreamHexHead", ",", "fileTypeEntry", ".", "getKey", "(", ")", ")", ")", "{", "return", "fileTypeEntry", ".", "getValue", "(", ")", ";", "}", "}", "return", "null", ";", "}"], "original_string": "public static String getType(String fileStreamHexHead) {\r\n\t\tfor (Entry<String, String> fileTypeEntry : fileTypeMap.entrySet()) {\r\n\t\t\tif(StrUtil.startWithIgnoreCase(fileStreamHexHead, fileTypeEntry.getKey())) {\r\n\t\t\t\treturn fileTypeEntry.getValue();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}"}, {"code": "public CellStyle getOrCreateRowStyle(int y) {\r\n\t\tfinal Row row = getOrCreateRow(y);\r\n\t\tCellStyle rowStyle = row.getRowStyle();\r\n\t\tif (null == rowStyle) {\r\n\t\t\trowStyle = this.workbook.createCellStyle();\r\n\t\t\trow.setRowStyle(rowStyle);\r\n\t\t}\r\n\t\treturn rowStyle;\r\n\t}", "code_tokens": ["public", "CellStyle", "getOrCreateRowStyle", "(", "int", "y", ")", "{", "final", "Row", "row", "=", "getOrCreateRow", "(", "y", ")", ";", "CellStyle", "rowStyle", "=", "row", ".", "getRowStyle", "(", ")", ";", "if", "(", "null", "==", "rowStyle", ")", "{", "rowStyle", "=", "this", ".", "workbook", ".", "createCellStyle", "(", ")", ";", "row", ".", "setRowStyle", "(", "rowStyle", ")", ";", "}", "return", "rowStyle", ";", "}"], "original_string": "public CellStyle getOrCreateRowStyle(int y) {\r\n\t\tfinal Row row = getOrCreateRow(y);\r\n\t\tCellStyle rowStyle = row.getRowStyle();\r\n\t\tif (null == rowStyle) {\r\n\t\t\trowStyle = this.workbook.createCellStyle();\r\n\t\t\trow.setRowStyle(rowStyle);\r\n\t\t}\r\n\t\treturn rowStyle;\r\n\t}"}, {"code": "private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout, Call call,\n      EventListener eventListener) throws IOException {\n    Request tunnelRequest = createTunnelRequest();\n    HttpUrl url = tunnelRequest.url();\n    for (int i = 0; i < MAX_TUNNEL_ATTEMPTS; i++) {\n      connectSocket(connectTimeout, readTimeout, call, eventListener);\n      tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);\n\n      if (tunnelRequest == null) break; // Tunnel successfully created.\n\n      // The proxy decided to close the connection after an auth challenge. We need to create a new\n      // connection, but this time with the auth credentials.\n      closeQuietly(rawSocket);\n      rawSocket = null;\n      sink = null;\n      source = null;\n      eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null);\n    }\n  }", "code_tokens": ["private", "void", "connectTunnel", "(", "int", "connectTimeout", ",", "int", "readTimeout", ",", "int", "writeTimeout", ",", "Call", "call", ",", "EventListener", "eventListener", ")", "throws", "IOException", "{", "Request", "tunnelRequest", "=", "createTunnelRequest", "(", ")", ";", "HttpUrl", "url", "=", "tunnelRequest", ".", "url", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "MAX_TUNNEL_ATTEMPTS", ";", "i", "++", ")", "{", "connectSocket", "(", "connectTimeout", ",", "readTimeout", ",", "call", ",", "eventListener", ")", ";", "tunnelRequest", "=", "createTunnel", "(", "readTimeout", ",", "writeTimeout", ",", "tunnelRequest", ",", "url", ")", ";", "if", "(", "tunnelRequest", "==", "null", ")", "break", ";", "// Tunnel successfully created.", "// The proxy decided to close the connection after an auth challenge. We need to create a new", "// connection, but this time with the auth credentials.", "closeQuietly", "(", "rawSocket", ")", ";", "rawSocket", "=", "null", ";", "sink", "=", "null", ";", "source", "=", "null", ";", "eventListener", ".", "connectEnd", "(", "call", ",", "route", ".", "socketAddress", "(", ")", ",", "route", ".", "proxy", "(", ")", ",", "null", ")", ";", "}", "}"], "original_string": "private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout, Call call,\n      EventListener eventListener) throws IOException {\n    Request tunnelRequest = createTunnelRequest();\n    HttpUrl url = tunnelRequest.url();\n    for (int i = 0; i < MAX_TUNNEL_ATTEMPTS; i++) {\n      connectSocket(connectTimeout, readTimeout, call, eventListener);\n      tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);\n\n      if (tunnelRequest == null) break; // Tunnel successfully created.\n\n      // The proxy decided to close the connection after an auth challenge. We need to create a new\n      // connection, but this time with the auth credentials.\n      closeQuietly(rawSocket);\n      rawSocket = null;\n      sink = null;\n      source = null;\n      eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null);\n    }\n  }"}, {"code": "public static String getType(File file) throws IORuntimeException {\r\n\t\tFileInputStream in = null;\r\n\t\ttry {\r\n\t\t\tin = IoUtil.toStream(file);\r\n\t\t\treturn getType(in);\r\n\t\t} finally {\r\n\t\t\tIoUtil.close(in);\r\n\t\t}\r\n\t}", "code_tokens": ["public", "static", "String", "getType", "(", "File", "file", ")", "throws", "IORuntimeException", "{", "FileInputStream", "in", "=", "null", ";", "try", "{", "in", "=", "IoUtil", ".", "toStream", "(", "file", ")", ";", "return", "getType", "(", "in", ")", ";", "}", "finally", "{", "IoUtil", ".", "close", "(", "in", ")", ";", "}", "}"], "original_string": "public static String getType(File file) throws IORuntimeException {\r\n\t\tFileInputStream in = null;\r\n\t\ttry {\r\n\t\t\tin = IoUtil.toStream(file);\r\n\t\t\treturn getType(in);\r\n\t\t} finally {\r\n\t\t\tIoUtil.close(in);\r\n\t\t}\r\n\t}"}, {"code": "public Task removeTask(ExecutionAttemptID executionAttemptID) {\n\t\tcheckInit();\n\n\t\tTaskSlotMapping taskSlotMapping = taskSlotMappings.remove(executionAttemptID);\n\n\t\tif (taskSlotMapping != null) {\n\t\t\tTask task = taskSlotMapping.getTask();\n\t\t\tTaskSlot taskSlot = taskSlotMapping.getTaskSlot();\n\n\t\t\ttaskSlot.remove(task.getExecutionId());\n\n\t\t\tif (taskSlot.isReleasing() && taskSlot.isEmpty()) {\n\t\t\t\tslotActions.freeSlot(taskSlot.getAllocationId());\n\t\t\t}\n\n\t\t\treturn task;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}", "code_tokens": ["public", "Task", "removeTask", "(", "ExecutionAttemptID", "executionAttemptID", ")", "{", "checkInit", "(", ")", ";", "TaskSlotMapping", "taskSlotMapping", "=", "taskSlotMappings", ".", "remove", "(", "executionAttemptID", ")", ";", "if", "(", "taskSlotMapping", "!=", "null", ")", "{", "Task", "task", "=", "taskSlotMapping", ".", "getTask", "(", ")", ";", "TaskSlot", "taskSlot", "=", "taskSlotMapping", ".", "getTaskSlot", "(", ")", ";", "taskSlot", ".", "remove", "(", "task", ".", "getExecutionId", "(", ")", ")", ";", "if", "(", "taskSlot", ".", "isReleasing", "(", ")", "&&", "taskSlot", ".", "isEmpty", "(", ")", ")", "{", "slotActions", ".", "freeSlot", "(", "taskSlot", ".", "getAllocationId", "(", ")", ")", ";", "}", "return", "task", ";", "}", "else", "{", "return", "null", ";", "}", "}"], "original_string": "public Task removeTask(ExecutionAttemptID executionAttemptID) {\n\t\tcheckInit();\n\n\t\tTaskSlotMapping taskSlotMapping = taskSlotMappings.remove(executionAttemptID);\n\n\t\tif (taskSlotMapping != null) {\n\t\t\tTask task = taskSlotMapping.getTask();\n\t\t\tTaskSlot taskSlot = taskSlotMapping.getTaskSlot();\n\n\t\t\ttaskSlot.remove(task.getExecutionId());\n\n\t\t\tif (taskSlot.isReleasing() && taskSlot.isEmpty()) {\n\t\t\t\tslotActions.freeSlot(taskSlot.getAllocationId());\n\t\t\t}\n\n\t\t\treturn task;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}"}, {"code": "private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory) {\n\t\tPreconditions.checkNotNull(t, \"Type parameter must not be null.\");\n\t\tPreconditions.checkNotNull(factory, \"Factory parameter must not be null.\");\n\n\t\tif (!TypeInfoFactory.class.isAssignableFrom(factory)) {\n\t\t\tthrow new IllegalArgumentException(\"Class is not a TypeInfoFactory.\");\n\t\t}\n\t\tif (registeredTypeInfoFactories.containsKey(t)) {\n\t\t\tthrow new InvalidTypesException(\"A TypeInfoFactory for type '\" + t + \"' is already registered.\");\n\t\t}\n\t\tregisteredTypeInfoFactories.put(t, factory);\n\t}", "code_tokens": ["private", "static", "void", "registerFactory", "(", "Type", "t", ",", "Class", "<", "?", "extends", "TypeInfoFactory", ">", "factory", ")", "{", "Preconditions", ".", "checkNotNull", "(", "t", ",", "\"Type parameter must not be null.\"", ")", ";", "Preconditions", ".", "checkNotNull", "(", "factory", ",", "\"Factory parameter must not be null.\"", ")", ";", "if", "(", "!", "TypeInfoFactory", ".", "class", ".", "isAssignableFrom", "(", "factory", ")", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"Class is not a TypeInfoFactory.\"", ")", ";", "}", "if", "(", "registeredTypeInfoFactories", ".", "containsKey", "(", "t", ")", ")", "{", "throw", "new", "InvalidTypesException", "(", "\"A TypeInfoFactory for type '\"", "+", "t", "+", "\"' is already registered.\"", ")", ";", "}", "registeredTypeInfoFactories", ".", "put", "(", "t", ",", "factory", ")", ";", "}"], "original_string": "private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory) {\n\t\tPreconditions.checkNotNull(t, \"Type parameter must not be null.\");\n\t\tPreconditions.checkNotNull(factory, \"Factory parameter must not be null.\");\n\n\t\tif (!TypeInfoFactory.class.isAssignableFrom(factory)) {\n\t\t\tthrow new IllegalArgumentException(\"Class is not a TypeInfoFactory.\");\n\t\t}\n\t\tif (registeredTypeInfoFactories.containsKey(t)) {\n\t\t\tthrow new InvalidTypesException(\"A TypeInfoFactory for type '\" + t + \"' is already registered.\");\n\t\t}\n\t\tregisteredTypeInfoFactories.put(t, factory);\n\t}"}, {"code": "public JSONWriter array() throws JSONException {\n    if (this.mode == 'i' || this.mode == 'o' || this.mode == 'a') {\n      this.push(null);\n      this.append(\"[\");\n      this.comma = false;\n      return this;\n    }\n    throw new JSONException(\"Misplaced array.\");\n  }", "code_tokens": ["public", "JSONWriter", "array", "(", ")", "throws", "JSONException", "{", "if", "(", "this", ".", "mode", "==", "'", "'", "||", "this", ".", "mode", "==", "'", "'", "||", "this", ".", "mode", "==", "'", "'", ")", "{", "this", ".", "push", "(", "null", ")", ";", "this", ".", "append", "(", "\"[\"", ")", ";", "this", ".", "comma", "=", "false", ";", "return", "this", ";", "}", "throw", "new", "JSONException", "(", "\"Misplaced array.\"", ")", ";", "}"], "original_string": "public JSONWriter array() throws JSONException {\n    if (this.mode == 'i' || this.mode == 'o' || this.mode == 'a') {\n      this.push(null);\n      this.append(\"[\");\n      this.comma = false;\n      return this;\n    }\n    throw new JSONException(\"Misplaced array.\");\n  }"}, {"code": "public static void unregisterMXBean(CacheProxy<?, ?> cache, MBeanType type) {\n    ObjectName objectName = getObjectName(cache, type);\n    unregister(objectName);\n  }", "code_tokens": ["public", "static", "void", "unregisterMXBean", "(", "CacheProxy", "<", "?", ",", "?", ">", "cache", ",", "MBeanType", "type", ")", "{", "ObjectName", "objectName", "=", "getObjectName", "(", "cache", ",", "type", ")", ";", "unregister", "(", "objectName", ")", ";", "}"], "original_string": "public static void unregisterMXBean(CacheProxy<?, ?> cache, MBeanType type) {\n    ObjectName objectName = getObjectName(cache, type);\n    unregister(objectName);\n  }"}, {"code": "private SM2 initCipherParams() {\r\n\t\ttry {\r\n\t\t\tif (null != this.publicKey) {\r\n\t\t\t\tthis.publicKeyParams = (ECPublicKeyParameters) ECUtil.generatePublicKeyParameter(this.publicKey);\r\n\t\t\t}\r\n\t\t\tif (null != privateKey) {\r\n\t\t\t\tthis.privateKeyParams = (ECPrivateKeyParameters) ECUtil.generatePrivateKeyParameter(this.privateKey);\r\n\t\t\t}\r\n\t\t} catch (InvalidKeyException e) {\r\n\t\t\tthrow new CryptoException(e);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}", "code_tokens": ["private", "SM2", "initCipherParams", "(", ")", "{", "try", "{", "if", "(", "null", "!=", "this", ".", "publicKey", ")", "{", "this", ".", "publicKeyParams", "=", "(", "ECPublicKeyParameters", ")", "ECUtil", ".", "generatePublicKeyParameter", "(", "this", ".", "publicKey", ")", ";", "}", "if", "(", "null", "!=", "privateKey", ")", "{", "this", ".", "privateKeyParams", "=", "(", "ECPrivateKeyParameters", ")", "ECUtil", ".", "generatePrivateKeyParameter", "(", "this", ".", "privateKey", ")", ";", "}", "}", "catch", "(", "InvalidKeyException", "e", ")", "{", "throw", "new", "CryptoException", "(", "e", ")", ";", "}", "return", "this", ";", "}"], "original_string": "private SM2 initCipherParams() {\r\n\t\ttry {\r\n\t\t\tif (null != this.publicKey) {\r\n\t\t\t\tthis.publicKeyParams = (ECPublicKeyParameters) ECUtil.generatePublicKeyParameter(this.publicKey);\r\n\t\t\t}\r\n\t\t\tif (null != privateKey) {\r\n\t\t\t\tthis.privateKeyParams = (ECPrivateKeyParameters) ECUtil.generatePrivateKeyParameter(this.privateKey);\r\n\t\t\t}\r\n\t\t} catch (InvalidKeyException e) {\r\n\t\t\tthrow new CryptoException(e);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}"}, {"code": "public StrBuilder insert(int index, CharSequence csq) {\n\t\tif (null == csq) {\n\t\t\tcsq = \"null\";\n\t\t}\n\t\tint len = csq.length();\n\t\tmoveDataAfterIndex(index, csq.length());\n\t\tif (csq instanceof String) {\n\t\t\t((String) csq).getChars(0, len, this.value, index);\n\t\t} else if (csq instanceof StringBuilder) {\n\t\t\t((StringBuilder) csq).getChars(0, len, this.value, index);\n\t\t} else if (csq instanceof StringBuffer) {\n\t\t\t((StringBuffer) csq).getChars(0, len, this.value, index);\n\t\t} else if (csq instanceof StrBuilder) {\n\t\t\t((StrBuilder) csq).getChars(0, len, this.value, index);\n\t\t} else {\n\t\t\tfor (int i = 0, j = this.position; i < len; i++, j++) {\n\t\t\t\tthis.value[j] = csq.charAt(i);\n\t\t\t}\n\t\t}\n\t\tthis.position = Math.max(this.position, index) + len;\n\t\treturn this;\n\t}", "code_tokens": ["public", "StrBuilder", "insert", "(", "int", "index", ",", "CharSequence", "csq", ")", "{", "if", "(", "null", "==", "csq", ")", "{", "csq", "=", "\"null\"", ";", "}", "int", "len", "=", "csq", ".", "length", "(", ")", ";", "moveDataAfterIndex", "(", "index", ",", "csq", ".", "length", "(", ")", ")", ";", "if", "(", "csq", "instanceof", "String", ")", "{", "(", "(", "String", ")", "csq", ")", ".", "getChars", "(", "0", ",", "len", ",", "this", ".", "value", ",", "index", ")", ";", "}", "else", "if", "(", "csq", "instanceof", "StringBuilder", ")", "{", "(", "(", "StringBuilder", ")", "csq", ")", ".", "getChars", "(", "0", ",", "len", ",", "this", ".", "value", ",", "index", ")", ";", "}", "else", "if", "(", "csq", "instanceof", "StringBuffer", ")", "{", "(", "(", "StringBuffer", ")", "csq", ")", ".", "getChars", "(", "0", ",", "len", ",", "this", ".", "value", ",", "index", ")", ";", "}", "else", "if", "(", "csq", "instanceof", "StrBuilder", ")", "{", "(", "(", "StrBuilder", ")", "csq", ")", ".", "getChars", "(", "0", ",", "len", ",", "this", ".", "value", ",", "index", ")", ";", "}", "else", "{", "for", "(", "int", "i", "=", "0", ",", "j", "=", "this", ".", "position", ";", "i", "<", "len", ";", "i", "++", ",", "j", "++", ")", "{", "this", ".", "value", "[", "j", "]", "=", "csq", ".", "charAt", "(", "i", ")", ";", "}", "}", "this", ".", "position", "=", "Math", ".", "max", "(", "this", ".", "position", ",", "index", ")", "+", "len", ";", "return", "this", ";", "}"], "original_string": "public StrBuilder insert(int index, CharSequence csq) {\n\t\tif (null == csq) {\n\t\t\tcsq = \"null\";\n\t\t}\n\t\tint len = csq.length();\n\t\tmoveDataAfterIndex(index, csq.length());\n\t\tif (csq instanceof String) {\n\t\t\t((String) csq).getChars(0, len, this.value, index);\n\t\t} else if (csq instanceof StringBuilder) {\n\t\t\t((StringBuilder) csq).getChars(0, len, this.value, index);\n\t\t} else if (csq instanceof StringBuffer) {\n\t\t\t((StringBuffer) csq).getChars(0, len, this.value, index);\n\t\t} else if (csq instanceof StrBuilder) {\n\t\t\t((StrBuilder) csq).getChars(0, len, this.value, index);\n\t\t} else {\n\t\t\tfor (int i = 0, j = this.position; i < len; i++, j++) {\n\t\t\t\tthis.value[j] = csq.charAt(i);\n\t\t\t}\n\t\t}\n\t\tthis.position = Math.max(this.position, index) + len;\n\t\treturn this;\n\t}"}, {"code": "private static Object callConstructor(final Class<?> cls, final Class<?>[] argTypes,\n      final Object[] args) {\n    try {\n      final Constructor<?> cons = cls.getConstructor(argTypes);\n      return cons.newInstance(args);\n    } catch (final InvocationTargetException e) {\n      throw getCause(e);\n    } catch (final IllegalAccessException | NoSuchMethodException | InstantiationException e) {\n      throw new IllegalStateException(e);\n    }\n  }", "code_tokens": ["private", "static", "Object", "callConstructor", "(", "final", "Class", "<", "?", ">", "cls", ",", "final", "Class", "<", "?", ">", "[", "]", "argTypes", ",", "final", "Object", "[", "]", "args", ")", "{", "try", "{", "final", "Constructor", "<", "?", ">", "cons", "=", "cls", ".", "getConstructor", "(", "argTypes", ")", ";", "return", "cons", ".", "newInstance", "(", "args", ")", ";", "}", "catch", "(", "final", "InvocationTargetException", "e", ")", "{", "throw", "getCause", "(", "e", ")", ";", "}", "catch", "(", "final", "IllegalAccessException", "|", "NoSuchMethodException", "|", "InstantiationException", "e", ")", "{", "throw", "new", "IllegalStateException", "(", "e", ")", ";", "}", "}"], "original_string": "private static Object callConstructor(final Class<?> cls, final Class<?>[] argTypes,\n      final Object[] args) {\n    try {\n      final Constructor<?> cons = cls.getConstructor(argTypes);\n      return cons.newInstance(args);\n    } catch (final InvocationTargetException e) {\n      throw getCause(e);\n    } catch (final IllegalAccessException | NoSuchMethodException | InstantiationException e) {\n      throw new IllegalStateException(e);\n    }\n  }"}, {"code": "public synchronized void remapNode(@NonNull Node node) {\n        version++;\n\n        if (buildMode == MeshBuildMode.MESH) {\n            node.getUpstreamNode().removeFromDownstreams(node);\n\n            boolean m = false;\n            for (val n : sortedNodes) {\n                // we dont want to remap node to itself\n                if (!Objects.equals(n, node) && n.status().equals(NodeStatus.ONLINE)) {\n                    n.addDownstreamNode(node);\n                    m = true;\n                    break;\n                }\n            }\n\n            // if we were unable to find good enough node - we'll map this node to the rootNode\n            if (!m) {\n                rootNode.addDownstreamNode(node);\n            }\n\n            // i hope we won't deadlock here? :)\n            synchronized (this) {\n                Collections.sort(sortedNodes);\n            }\n        } else if (buildMode == MeshBuildMode.PLAIN) {\n            // nothing to do here\n        }\n    }", "code_tokens": ["public", "synchronized", "void", "remapNode", "(", "@", "NonNull", "Node", "node", ")", "{", "version", "++", ";", "if", "(", "buildMode", "==", "MeshBuildMode", ".", "MESH", ")", "{", "node", ".", "getUpstreamNode", "(", ")", ".", "removeFromDownstreams", "(", "node", ")", ";", "boolean", "m", "=", "false", ";", "for", "(", "val", "n", ":", "sortedNodes", ")", "{", "// we dont want to remap node to itself", "if", "(", "!", "Objects", ".", "equals", "(", "n", ",", "node", ")", "&&", "n", ".", "status", "(", ")", ".", "equals", "(", "NodeStatus", ".", "ONLINE", ")", ")", "{", "n", ".", "addDownstreamNode", "(", "node", ")", ";", "m", "=", "true", ";", "break", ";", "}", "}", "// if we were unable to find good enough node - we'll map this node to the rootNode", "if", "(", "!", "m", ")", "{", "rootNode", ".", "addDownstreamNode", "(", "node", ")", ";", "}", "// i hope we won't deadlock here? :)", "synchronized", "(", "this", ")", "{", "Collections", ".", "sort", "(", "sortedNodes", ")", ";", "}", "}", "else", "if", "(", "buildMode", "==", "MeshBuildMode", ".", "PLAIN", ")", "{", "// nothing to do here", "}", "}"], "original_string": "public synchronized void remapNode(@NonNull Node node) {\n        version++;\n\n        if (buildMode == MeshBuildMode.MESH) {\n            node.getUpstreamNode().removeFromDownstreams(node);\n\n            boolean m = false;\n            for (val n : sortedNodes) {\n                // we dont want to remap node to itself\n                if (!Objects.equals(n, node) && n.status().equals(NodeStatus.ONLINE)) {\n                    n.addDownstreamNode(node);\n                    m = true;\n                    break;\n                }\n            }\n\n            // if we were unable to find good enough node - we'll map this node to the rootNode\n            if (!m) {\n                rootNode.addDownstreamNode(node);\n            }\n\n            // i hope we won't deadlock here? :)\n            synchronized (this) {\n                Collections.sort(sortedNodes);\n            }\n        } else if (buildMode == MeshBuildMode.PLAIN) {\n            // nothing to do here\n        }\n    }"}, {"code": "public static final ByteArray copyFrom(String string) {\n    return new ByteArray(ByteString.copyFrom(string, StandardCharsets.UTF_8));\n  }", "code_tokens": ["public", "static", "final", "ByteArray", "copyFrom", "(", "String", "string", ")", "{", "return", "new", "ByteArray", "(", "ByteString", ".", "copyFrom", "(", "string", ",", "StandardCharsets", ".", "UTF_8", ")", ")", ";", "}"], "original_string": "public static final ByteArray copyFrom(String string) {\n    return new ByteArray(ByteString.copyFrom(string, StandardCharsets.UTF_8));\n  }"}, {"code": "public static byte[] sha1X16(String data, String encoding) {\n\t\tbyte[] bytes = sha1(data, encoding);\n\t\tStringBuilder sha1StrBuff = new StringBuilder();\n\t\tfor (int i = 0; i < bytes.length; i++) {\n\t\t\tif (Integer.toHexString(0xFF & bytes[i]).length() == 1) {\n\t\t\t\tsha1StrBuff.append(\"0\").append(\n\t\t\t\t\t\tInteger.toHexString(0xFF & bytes[i]));\n\t\t\t} else {\n\t\t\t\tsha1StrBuff.append(Integer.toHexString(0xFF & bytes[i]));\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\treturn sha1StrBuff.toString().getBytes(encoding);\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tLogUtil.writeErrorLog(e.getMessage(), e);\n\t\t\treturn null;\n\t\t}\n\t}", "code_tokens": ["public", "static", "byte", "[", "]", "sha1X16", "(", "String", "data", ",", "String", "encoding", ")", "{", "byte", "[", "]", "bytes", "=", "sha1", "(", "data", ",", "encoding", ")", ";", "StringBuilder", "sha1StrBuff", "=", "new", "StringBuilder", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "bytes", ".", "length", ";", "i", "++", ")", "{", "if", "(", "Integer", ".", "toHexString", "(", "0xFF", "&", "bytes", "[", "i", "]", ")", ".", "length", "(", ")", "==", "1", ")", "{", "sha1StrBuff", ".", "append", "(", "\"0\"", ")", ".", "append", "(", "Integer", ".", "toHexString", "(", "0xFF", "&", "bytes", "[", "i", "]", ")", ")", ";", "}", "else", "{", "sha1StrBuff", ".", "append", "(", "Integer", ".", "toHexString", "(", "0xFF", "&", "bytes", "[", "i", "]", ")", ")", ";", "}", "}", "try", "{", "return", "sha1StrBuff", ".", "toString", "(", ")", ".", "getBytes", "(", "encoding", ")", ";", "}", "catch", "(", "UnsupportedEncodingException", "e", ")", "{", "LogUtil", ".", "writeErrorLog", "(", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "return", "null", ";", "}", "}"], "original_string": "public static byte[] sha1X16(String data, String encoding) {\n\t\tbyte[] bytes = sha1(data, encoding);\n\t\tStringBuilder sha1StrBuff = new StringBuilder();\n\t\tfor (int i = 0; i < bytes.length; i++) {\n\t\t\tif (Integer.toHexString(0xFF & bytes[i]).length() == 1) {\n\t\t\t\tsha1StrBuff.append(\"0\").append(\n\t\t\t\t\t\tInteger.toHexString(0xFF & bytes[i]));\n\t\t\t} else {\n\t\t\t\tsha1StrBuff.append(Integer.toHexString(0xFF & bytes[i]));\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\treturn sha1StrBuff.toString().getBytes(encoding);\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tLogUtil.writeErrorLog(e.getMessage(), e);\n\t\t\treturn null;\n\t\t}\n\t}"}, {"code": "public com.google.privacy.dlp.v2.PrivacyMetric.DeltaPresenceEstimationConfig\n      getDeltaPresenceEstimationConfig() {\n    if (typeCase_ == 6) {\n      return (com.google.privacy.dlp.v2.PrivacyMetric.DeltaPresenceEstimationConfig) type_;\n    }\n    return com.google.privacy.dlp.v2.PrivacyMetric.DeltaPresenceEstimationConfig\n        .getDefaultInstance();\n  }", "code_tokens": ["public", "com", ".", "google", ".", "privacy", ".", "dlp", ".", "v2", ".", "PrivacyMetric", ".", "DeltaPresenceEstimationConfig", "getDeltaPresenceEstimationConfig", "(", ")", "{", "if", "(", "typeCase_", "==", "6", ")", "{", "return", "(", "com", ".", "google", ".", "privacy", ".", "dlp", ".", "v2", ".", "PrivacyMetric", ".", "DeltaPresenceEstimationConfig", ")", "type_", ";", "}", "return", "com", ".", "google", ".", "privacy", ".", "dlp", ".", "v2", ".", "PrivacyMetric", ".", "DeltaPresenceEstimationConfig", ".", "getDefaultInstance", "(", ")", ";", "}"], "original_string": "public com.google.privacy.dlp.v2.PrivacyMetric.DeltaPresenceEstimationConfig\n      getDeltaPresenceEstimationConfig() {\n    if (typeCase_ == 6) {\n      return (com.google.privacy.dlp.v2.PrivacyMetric.DeltaPresenceEstimationConfig) type_;\n    }\n    return com.google.privacy.dlp.v2.PrivacyMetric.DeltaPresenceEstimationConfig\n        .getDefaultInstance();\n  }"}, {"code": "private static byte[] lmResponse(final byte[] hash, final byte[] challenge) throws AuthenticationException {\n        try {\n            final byte[] keyBytes = new byte[21];\n            System.arraycopy(hash, 0, keyBytes, 0, 16);\n            final Key lowKey = createDESKey(keyBytes, 0);\n            final Key middleKey = createDESKey(keyBytes, 7);\n            final Key highKey = createDESKey(keyBytes, 14);\n            final Cipher des = Cipher.getInstance(\"DES/ECB/NoPadding\");\n            des.init(Cipher.ENCRYPT_MODE, lowKey);\n            final byte[] lowResponse = des.doFinal(challenge);\n            des.init(Cipher.ENCRYPT_MODE, middleKey);\n            final byte[] middleResponse = des.doFinal(challenge);\n            des.init(Cipher.ENCRYPT_MODE, highKey);\n            final byte[] highResponse = des.doFinal(challenge);\n            final byte[] lmResponse = new byte[24];\n            System.arraycopy(lowResponse, 0, lmResponse, 0, 8);\n            System.arraycopy(middleResponse, 0, lmResponse, 8, 8);\n            System.arraycopy(highResponse, 0, lmResponse, 16, 8);\n            return lmResponse;\n        } catch (final Exception e) {\n            throw new AuthenticationException(e.getMessage(), e);\n        }\n    }", "code_tokens": ["private", "static", "byte", "[", "]", "lmResponse", "(", "final", "byte", "[", "]", "hash", ",", "final", "byte", "[", "]", "challenge", ")", "throws", "AuthenticationException", "{", "try", "{", "final", "byte", "[", "]", "keyBytes", "=", "new", "byte", "[", "21", "]", ";", "System", ".", "arraycopy", "(", "hash", ",", "0", ",", "keyBytes", ",", "0", ",", "16", ")", ";", "final", "Key", "lowKey", "=", "createDESKey", "(", "keyBytes", ",", "0", ")", ";", "final", "Key", "middleKey", "=", "createDESKey", "(", "keyBytes", ",", "7", ")", ";", "final", "Key", "highKey", "=", "createDESKey", "(", "keyBytes", ",", "14", ")", ";", "final", "Cipher", "des", "=", "Cipher", ".", "getInstance", "(", "\"DES/ECB/NoPadding\"", ")", ";", "des", ".", "init", "(", "Cipher", ".", "ENCRYPT_MODE", ",", "lowKey", ")", ";", "final", "byte", "[", "]", "lowResponse", "=", "des", ".", "doFinal", "(", "challenge", ")", ";", "des", ".", "init", "(", "Cipher", ".", "ENCRYPT_MODE", ",", "middleKey", ")", ";", "final", "byte", "[", "]", "middleResponse", "=", "des", ".", "doFinal", "(", "challenge", ")", ";", "des", ".", "init", "(", "Cipher", ".", "ENCRYPT_MODE", ",", "highKey", ")", ";", "final", "byte", "[", "]", "highResponse", "=", "des", ".", "doFinal", "(", "challenge", ")", ";", "final", "byte", "[", "]", "lmResponse", "=", "new", "byte", "[", "24", "]", ";", "System", ".", "arraycopy", "(", "lowResponse", ",", "0", ",", "lmResponse", ",", "0", ",", "8", ")", ";", "System", ".", "arraycopy", "(", "middleResponse", ",", "0", ",", "lmResponse", ",", "8", ",", "8", ")", ";", "System", ".", "arraycopy", "(", "highResponse", ",", "0", ",", "lmResponse", ",", "16", ",", "8", ")", ";", "return", "lmResponse", ";", "}", "catch", "(", "final", "Exception", "e", ")", "{", "throw", "new", "AuthenticationException", "(", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "}", "}"], "original_string": "private static byte[] lmResponse(final byte[] hash, final byte[] challenge) throws AuthenticationException {\n        try {\n            final byte[] keyBytes = new byte[21];\n            System.arraycopy(hash, 0, keyBytes, 0, 16);\n            final Key lowKey = createDESKey(keyBytes, 0);\n            final Key middleKey = createDESKey(keyBytes, 7);\n            final Key highKey = createDESKey(keyBytes, 14);\n            final Cipher des = Cipher.getInstance(\"DES/ECB/NoPadding\");\n            des.init(Cipher.ENCRYPT_MODE, lowKey);\n            final byte[] lowResponse = des.doFinal(challenge);\n            des.init(Cipher.ENCRYPT_MODE, middleKey);\n            final byte[] middleResponse = des.doFinal(challenge);\n            des.init(Cipher.ENCRYPT_MODE, highKey);\n            final byte[] highResponse = des.doFinal(challenge);\n            final byte[] lmResponse = new byte[24];\n            System.arraycopy(lowResponse, 0, lmResponse, 0, 8);\n            System.arraycopy(middleResponse, 0, lmResponse, 8, 8);\n            System.arraycopy(highResponse, 0, lmResponse, 16, 8);\n            return lmResponse;\n        } catch (final Exception e) {\n            throw new AuthenticationException(e.getMessage(), e);\n        }\n    }"}, {"code": "@BetaApi\n  public final AggregatedListVpnTunnelsPagedResponse aggregatedListVpnTunnels(String project) {\n    AggregatedListVpnTunnelsHttpRequest request =\n        AggregatedListVpnTunnelsHttpRequest.newBuilder().setProject(project).build();\n    return aggregatedListVpnTunnels(request);\n  }", "code_tokens": ["@", "BetaApi", "public", "final", "AggregatedListVpnTunnelsPagedResponse", "aggregatedListVpnTunnels", "(", "String", "project", ")", "{", "AggregatedListVpnTunnelsHttpRequest", "request", "=", "AggregatedListVpnTunnelsHttpRequest", ".", "newBuilder", "(", ")", ".", "setProject", "(", "project", ")", ".", "build", "(", ")", ";", "return", "aggregatedListVpnTunnels", "(", "request", ")", ";", "}"], "original_string": "@BetaApi\n  public final AggregatedListVpnTunnelsPagedResponse aggregatedListVpnTunnels(String project) {\n    AggregatedListVpnTunnelsHttpRequest request =\n        AggregatedListVpnTunnelsHttpRequest.newBuilder().setProject(project).build();\n    return aggregatedListVpnTunnels(request);\n  }"}, {"code": "public void initialize() {\n        if (Ignition.state() == IgniteState.STOPPED) {\n            this.ignite = Ignition.start(igniteConfiguration);\n            LOGGER.debug(\"Starting ignite cache engine\");\n        } else if (Ignition.state() == IgniteState.STARTED) {\n            this.ignite = Ignition.ignite();\n            LOGGER.debug(\"Ignite cache engine has started\");\n        }\n    }", "code_tokens": ["public", "void", "initialize", "(", ")", "{", "if", "(", "Ignition", ".", "state", "(", ")", "==", "IgniteState", ".", "STOPPED", ")", "{", "this", ".", "ignite", "=", "Ignition", ".", "start", "(", "igniteConfiguration", ")", ";", "LOGGER", ".", "debug", "(", "\"Starting ignite cache engine\"", ")", ";", "}", "else", "if", "(", "Ignition", ".", "state", "(", ")", "==", "IgniteState", ".", "STARTED", ")", "{", "this", ".", "ignite", "=", "Ignition", ".", "ignite", "(", ")", ";", "LOGGER", ".", "debug", "(", "\"Ignite cache engine has started\"", ")", ";", "}", "}"], "original_string": "public void initialize() {\n        if (Ignition.state() == IgniteState.STOPPED) {\n            this.ignite = Ignition.start(igniteConfiguration);\n            LOGGER.debug(\"Starting ignite cache engine\");\n        } else if (Ignition.state() == IgniteState.STARTED) {\n            this.ignite = Ignition.ignite();\n            LOGGER.debug(\"Ignite cache engine has started\");\n        }\n    }"}, {"code": "public String convertToPageSql(String sql, Integer offset, Integer limit) {\n        //\u89e3\u6790SQL\n        Statement stmt;\n        try {\n            stmt = CCJSqlParserUtil.parse(sql);\n        } catch (Throwable e) {\n            throw new PageException(\"\u4e0d\u652f\u6301\u8be5SQL\u8f6c\u6362\u4e3a\u5206\u9875\u67e5\u8be2!\", e);\n        }\n        if (!(stmt instanceof Select)) {\n            throw new PageException(\"\u5206\u9875\u8bed\u53e5\u5fc5\u987b\u662fSelect\u67e5\u8be2!\");\n        }\n        //\u83b7\u53d6\u5206\u9875\u67e5\u8be2\u7684select\n        Select pageSelect = getPageSelect((Select) stmt);\n        String pageSql = pageSelect.toString();\n        //\u7f13\u5b58\u79fb\u5230\u5916\u9762\u4e86\uff0c\u6240\u4ee5\u4e0d\u66ff\u6362\u53c2\u6570\n        if (offset != null) {\n            pageSql = pageSql.replace(START_ROW, String.valueOf(offset));\n        }\n        if (limit != null) {\n            pageSql = pageSql.replace(PAGE_SIZE, String.valueOf(limit));\n        }\n        return pageSql;\n    }", "code_tokens": ["public", "String", "convertToPageSql", "(", "String", "sql", ",", "Integer", "offset", ",", "Integer", "limit", ")", "{", "//\u89e3\u6790SQL", "Statement", "stmt", ";", "try", "{", "stmt", "=", "CCJSqlParserUtil", ".", "parse", "(", "sql", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "throw", "new", "PageException", "(", "\"\u4e0d\u652f\u6301\u8be5SQL\u8f6c\u6362\u4e3a\u5206\u9875\u67e5\u8be2!\", e);", "", "", "", "", "}", "if", "(", "!", "(", "stmt", "instanceof", "Select", ")", ")", "{", "throw", "new", "PageException", "(", "\"\u5206\u9875\u8bed\u53e5\u5fc5\u987b\u662fSelect\u67e5\u8be2!\");", "", "", "}", "//\u83b7\u53d6\u5206\u9875\u67e5\u8be2\u7684select", "Select", "pageSelect", "=", "getPageSelect", "(", "(", "Select", ")", "stmt", ")", ";", "String", "pageSql", "=", "pageSelect", ".", "toString", "(", ")", ";", "//\u7f13\u5b58\u79fb\u5230\u5916\u9762\u4e86\uff0c\u6240\u4ee5\u4e0d\u66ff\u6362\u53c2\u6570", "if", "(", "offset", "!=", "null", ")", "{", "pageSql", "=", "pageSql", ".", "replace", "(", "START_ROW", ",", "String", ".", "valueOf", "(", "offset", ")", ")", ";", "}", "if", "(", "limit", "!=", "null", ")", "{", "pageSql", "=", "pageSql", ".", "replace", "(", "PAGE_SIZE", ",", "String", ".", "valueOf", "(", "limit", ")", ")", ";", "}", "return", "pageSql", ";", "}"], "original_string": "public String convertToPageSql(String sql, Integer offset, Integer limit) {\n        //\u89e3\u6790SQL\n        Statement stmt;\n        try {\n            stmt = CCJSqlParserUtil.parse(sql);\n        } catch (Throwable e) {\n            throw new PageException(\"\u4e0d\u652f\u6301\u8be5SQL\u8f6c\u6362\u4e3a\u5206\u9875\u67e5\u8be2!\", e);\n        }\n        if (!(stmt instanceof Select)) {\n            throw new PageException(\"\u5206\u9875\u8bed\u53e5\u5fc5\u987b\u662fSelect\u67e5\u8be2!\");\n        }\n        //\u83b7\u53d6\u5206\u9875\u67e5\u8be2\u7684select\n        Select pageSelect = getPageSelect((Select) stmt);\n        String pageSql = pageSelect.toString();\n        //\u7f13\u5b58\u79fb\u5230\u5916\u9762\u4e86\uff0c\u6240\u4ee5\u4e0d\u66ff\u6362\u53c2\u6570\n        if (offset != null) {\n            pageSql = pageSql.replace(START_ROW, String.valueOf(offset));\n        }\n        if (limit != null) {\n            pageSql = pageSql.replace(PAGE_SIZE, String.valueOf(limit));\n        }\n        return pageSql;\n    }"}, {"code": "public static String resolveWildCardForJarSpec(String workingDirectory, String unresolvedJarSpec,\n      Logger log) {\n\n    log.debug(\"resolveWildCardForJarSpec: unresolved jar specification: \" + unresolvedJarSpec);\n    log.debug(\"working directory: \" + workingDirectory);\n\n    if (unresolvedJarSpec == null || unresolvedJarSpec.isEmpty()) {\n      return \"\";\n    }\n\n    StringBuilder resolvedJarSpec = new StringBuilder();\n\n    String[] unresolvedJarSpecList = unresolvedJarSpec.split(\",\");\n    for (String s : unresolvedJarSpecList) {\n      // if need resolution\n      if (s.endsWith(\"*\")) {\n        // remove last 2 characters to get to the folder\n        String dirName = String.format(\"%s/%s\", workingDirectory, s.substring(0, s.length() - 2));\n\n        File[] jars = null;\n        try {\n          jars = getFilesInFolderByRegex(new File(dirName), \".*jar\");\n        } catch (FileNotFoundException fnfe) {\n          log.warn(\"folder does not exist: \" + dirName);\n          continue;\n        }\n\n        // if the folder is there, add them to the jar list\n        for (File jar : jars) {\n          resolvedJarSpec.append(jar.toString()).append(\",\");\n        }\n      } else { // no need for resolution\n        resolvedJarSpec.append(s).append(\",\");\n      }\n    }\n\n    log.debug(\"resolveWildCardForJarSpec: resolvedJarSpec: \" + resolvedJarSpec);\n\n    // remove the trailing comma\n    int lastCharIndex = resolvedJarSpec.length() - 1;\n    if (lastCharIndex >= 0 && resolvedJarSpec.charAt(lastCharIndex) == ',') {\n      resolvedJarSpec.deleteCharAt(lastCharIndex);\n    }\n\n    return resolvedJarSpec.toString();\n  }", "code_tokens": ["public", "static", "String", "resolveWildCardForJarSpec", "(", "String", "workingDirectory", ",", "String", "unresolvedJarSpec", ",", "Logger", "log", ")", "{", "log", ".", "debug", "(", "\"resolveWildCardForJarSpec: unresolved jar specification: \"", "+", "unresolvedJarSpec", ")", ";", "log", ".", "debug", "(", "\"working directory: \"", "+", "workingDirectory", ")", ";", "if", "(", "unresolvedJarSpec", "==", "null", "||", "unresolvedJarSpec", ".", "isEmpty", "(", ")", ")", "{", "return", "\"\"", ";", "}", "StringBuilder", "resolvedJarSpec", "=", "new", "StringBuilder", "(", ")", ";", "String", "[", "]", "unresolvedJarSpecList", "=", "unresolvedJarSpec", ".", "split", "(", "\",\"", ")", ";", "for", "(", "String", "s", ":", "unresolvedJarSpecList", ")", "{", "// if need resolution", "if", "(", "s", ".", "endsWith", "(", "\"*\"", ")", ")", "{", "// remove last 2 characters to get to the folder", "String", "dirName", "=", "String", ".", "format", "(", "\"%s/%s\"", ",", "workingDirectory", ",", "s", ".", "substring", "(", "0", ",", "s", ".", "length", "(", ")", "-", "2", ")", ")", ";", "File", "[", "]", "jars", "=", "null", ";", "try", "{", "jars", "=", "getFilesInFolderByRegex", "(", "new", "File", "(", "dirName", ")", ",", "\".*jar\"", ")", ";", "}", "catch", "(", "FileNotFoundException", "fnfe", ")", "{", "log", ".", "warn", "(", "\"folder does not exist: \"", "+", "dirName", ")", ";", "continue", ";", "}", "// if the folder is there, add them to the jar list", "for", "(", "File", "jar", ":", "jars", ")", "{", "resolvedJarSpec", ".", "append", "(", "jar", ".", "toString", "(", ")", ")", ".", "append", "(", "\",\"", ")", ";", "}", "}", "else", "{", "// no need for resolution", "resolvedJarSpec", ".", "append", "(", "s", ")", ".", "append", "(", "\",\"", ")", ";", "}", "}", "log", ".", "debug", "(", "\"resolveWildCardForJarSpec: resolvedJarSpec: \"", "+", "resolvedJarSpec", ")", ";", "// remove the trailing comma", "int", "lastCharIndex", "=", "resolvedJarSpec", ".", "length", "(", ")", "-", "1", ";", "if", "(", "lastCharIndex", ">=", "0", "&&", "resolvedJarSpec", ".", "charAt", "(", "lastCharIndex", ")", "==", "'", "'", ")", "{", "resolvedJarSpec", ".", "deleteCharAt", "(", "lastCharIndex", ")", ";", "}", "return", "resolvedJarSpec", ".", "toString", "(", ")", ";", "}"], "original_string": "public static String resolveWildCardForJarSpec(String workingDirectory, String unresolvedJarSpec,\n      Logger log) {\n\n    log.debug(\"resolveWildCardForJarSpec: unresolved jar specification: \" + unresolvedJarSpec);\n    log.debug(\"working directory: \" + workingDirectory);\n\n    if (unresolvedJarSpec == null || unresolvedJarSpec.isEmpty()) {\n      return \"\";\n    }\n\n    StringBuilder resolvedJarSpec = new StringBuilder();\n\n    String[] unresolvedJarSpecList = unresolvedJarSpec.split(\",\");\n    for (String s : unresolvedJarSpecList) {\n      // if need resolution\n      if (s.endsWith(\"*\")) {\n        // remove last 2 characters to get to the folder\n        String dirName = String.format(\"%s/%s\", workingDirectory, s.substring(0, s.length() - 2));\n\n        File[] jars = null;\n        try {\n          jars = getFilesInFolderByRegex(new File(dirName), \".*jar\");\n        } catch (FileNotFoundException fnfe) {\n          log.warn(\"folder does not exist: \" + dirName);\n          continue;\n        }\n\n        // if the folder is there, add them to the jar list\n        for (File jar : jars) {\n          resolvedJarSpec.append(jar.toString()).append(\",\");\n        }\n      } else { // no need for resolution\n        resolvedJarSpec.append(s).append(\",\");\n      }\n    }\n\n    log.debug(\"resolveWildCardForJarSpec: resolvedJarSpec: \" + resolvedJarSpec);\n\n    // remove the trailing comma\n    int lastCharIndex = resolvedJarSpec.length() - 1;\n    if (lastCharIndex >= 0 && resolvedJarSpec.charAt(lastCharIndex) == ',') {\n      resolvedJarSpec.deleteCharAt(lastCharIndex);\n    }\n\n    return resolvedJarSpec.toString();\n  }"}, {"code": "public static <E> Enumeration<E> asEnumeration(Iterator<E> iter) {\r\n\t\treturn new IteratorEnumeration<E>(iter);\r\n\t}", "code_tokens": ["public", "static", "<", "E", ">", "Enumeration", "<", "E", ">", "asEnumeration", "(", "Iterator", "<", "E", ">", "iter", ")", "{", "return", "new", "IteratorEnumeration", "<", "E", ">", "(", "iter", ")", ";", "}"], "original_string": "public static <E> Enumeration<E> asEnumeration(Iterator<E> iter) {\r\n\t\treturn new IteratorEnumeration<E>(iter);\r\n\t}"}, {"code": "public boolean getBoolean(String key, boolean defaultValue) {\n\t\tObject o = getRawValue(key);\n\t\tif (o == null) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\treturn convertToBoolean(o);\n\t}", "code_tokens": ["public", "boolean", "getBoolean", "(", "String", "key", ",", "boolean", "defaultValue", ")", "{", "Object", "o", "=", "getRawValue", "(", "key", ")", ";", "if", "(", "o", "==", "null", ")", "{", "return", "defaultValue", ";", "}", "return", "convertToBoolean", "(", "o", ")", ";", "}"], "original_string": "public boolean getBoolean(String key, boolean defaultValue) {\n\t\tObject o = getRawValue(key);\n\t\tif (o == null) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\treturn convertToBoolean(o);\n\t}"}, {"code": "public Token scanSymbol() {\n        int length = 0;\n        while (CharType.isSymbol(charAt(offset + length))) {\n            length++;\n        }\n        String literals = input.substring(offset, offset + length);\n        Symbol symbol;\n        while (null == (symbol = Symbol.literalsOf(literals))) {\n            literals = input.substring(offset, offset + --length);\n        }\n        return new Token(symbol, literals, offset + length);\n    }", "code_tokens": ["public", "Token", "scanSymbol", "(", ")", "{", "int", "length", "=", "0", ";", "while", "(", "CharType", ".", "isSymbol", "(", "charAt", "(", "offset", "+", "length", ")", ")", ")", "{", "length", "++", ";", "}", "String", "literals", "=", "input", ".", "substring", "(", "offset", ",", "offset", "+", "length", ")", ";", "Symbol", "symbol", ";", "while", "(", "null", "==", "(", "symbol", "=", "Symbol", ".", "literalsOf", "(", "literals", ")", ")", ")", "{", "literals", "=", "input", ".", "substring", "(", "offset", ",", "offset", "+", "--", "length", ")", ";", "}", "return", "new", "Token", "(", "symbol", ",", "literals", ",", "offset", "+", "length", ")", ";", "}"], "original_string": "public Token scanSymbol() {\n        int length = 0;\n        while (CharType.isSymbol(charAt(offset + length))) {\n            length++;\n        }\n        String literals = input.substring(offset, offset + length);\n        Symbol symbol;\n        while (null == (symbol = Symbol.literalsOf(literals))) {\n            literals = input.substring(offset, offset + --length);\n        }\n        return new Token(symbol, literals, offset + length);\n    }"}, {"code": "protected boolean isMatchingZXY(Op opA, Op opB) {\n        if (opA.z() == opB.x() || opA.z() == opB.y())\n            return true;\n\n        return false;\n    }", "code_tokens": ["protected", "boolean", "isMatchingZXY", "(", "Op", "opA", ",", "Op", "opB", ")", "{", "if", "(", "opA", ".", "z", "(", ")", "==", "opB", ".", "x", "(", ")", "||", "opA", ".", "z", "(", ")", "==", "opB", ".", "y", "(", ")", ")", "return", "true", ";", "return", "false", ";", "}"], "original_string": "protected boolean isMatchingZXY(Op opA, Op opB) {\n        if (opA.z() == opB.x() || opA.z() == opB.y())\n            return true;\n\n        return false;\n    }"}, {"code": "public static <T> List<List<T>> group(Collection<T> collection, Hash<T> hash) {\r\n\t\tfinal List<List<T>> result = new ArrayList<>();\r\n\t\tif (isEmpty(collection)) {\r\n\t\t\treturn result;\r\n\t\t}\r\n\t\tif (null == hash) {\r\n\t\t\t// \u9ed8\u8ba4hash\u7b97\u6cd5\uff0c\u6309\u7167\u5143\u7d20\u7684hashCode\u5206\u7ec4\r\n\t\t\thash = new Hash<T>() {\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic int hash(T t) {\r\n\t\t\t\t\treturn null == t ? 0 : t.hashCode();\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tint index;\r\n\t\tList<T> subList;\r\n\t\tfor (T t : collection) {\r\n\t\t\tindex = hash.hash(t);\r\n\t\t\tif (result.size() - 1 < index) {\r\n\t\t\t\twhile (result.size() - 1 < index) {\r\n\t\t\t\t\tresult.add(null);\r\n\t\t\t\t}\r\n\t\t\t\tresult.set(index, newArrayList(t));\r\n\t\t\t} else {\r\n\t\t\t\tsubList = result.get(index);\r\n\t\t\t\tif (null == subList) {\r\n\t\t\t\t\tresult.set(index, newArrayList(t));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsubList.add(t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}", "code_tokens": ["public", "static", "<", "T", ">", "List", "<", "List", "<", "T", ">", ">", "group", "(", "Collection", "<", "T", ">", "collection", ",", "Hash", "<", "T", ">", "hash", ")", "{", "final", "List", "<", "List", "<", "T", ">", ">", "result", "=", "new", "ArrayList", "<>", "(", ")", ";", "if", "(", "isEmpty", "(", "collection", ")", ")", "{", "return", "result", ";", "}", "if", "(", "null", "==", "hash", ")", "{", "// \u9ed8\u8ba4hash\u7b97\u6cd5\uff0c\u6309\u7167\u5143\u7d20\u7684hashCode\u5206\u7ec4\r", "hash", "=", "new", "Hash", "<", "T", ">", "(", ")", "{", "@", "Override", "public", "int", "hash", "(", "T", "t", ")", "{", "return", "null", "==", "t", "?", "0", ":", "t", ".", "hashCode", "(", ")", ";", "}", "}", ";", "}", "int", "index", ";", "List", "<", "T", ">", "subList", ";", "for", "(", "T", "t", ":", "collection", ")", "{", "index", "=", "hash", ".", "hash", "(", "t", ")", ";", "if", "(", "result", ".", "size", "(", ")", "-", "1", "<", "index", ")", "{", "while", "(", "result", ".", "size", "(", ")", "-", "1", "<", "index", ")", "{", "result", ".", "add", "(", "null", ")", ";", "}", "result", ".", "set", "(", "index", ",", "newArrayList", "(", "t", ")", ")", ";", "}", "else", "{", "subList", "=", "result", ".", "get", "(", "index", ")", ";", "if", "(", "null", "==", "subList", ")", "{", "result", ".", "set", "(", "index", ",", "newArrayList", "(", "t", ")", ")", ";", "}", "else", "{", "subList", ".", "add", "(", "t", ")", ";", "}", "}", "}", "return", "result", ";", "}"], "original_string": "public static <T> List<List<T>> group(Collection<T> collection, Hash<T> hash) {\r\n\t\tfinal List<List<T>> result = new ArrayList<>();\r\n\t\tif (isEmpty(collection)) {\r\n\t\t\treturn result;\r\n\t\t}\r\n\t\tif (null == hash) {\r\n\t\t\t// \u9ed8\u8ba4hash\u7b97\u6cd5\uff0c\u6309\u7167\u5143\u7d20\u7684hashCode\u5206\u7ec4\r\n\t\t\thash = new Hash<T>() {\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic int hash(T t) {\r\n\t\t\t\t\treturn null == t ? 0 : t.hashCode();\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tint index;\r\n\t\tList<T> subList;\r\n\t\tfor (T t : collection) {\r\n\t\t\tindex = hash.hash(t);\r\n\t\t\tif (result.size() - 1 < index) {\r\n\t\t\t\twhile (result.size() - 1 < index) {\r\n\t\t\t\t\tresult.add(null);\r\n\t\t\t\t}\r\n\t\t\t\tresult.set(index, newArrayList(t));\r\n\t\t\t} else {\r\n\t\t\t\tsubList = result.get(index);\r\n\t\t\t\tif (null == subList) {\r\n\t\t\t\t\tresult.set(index, newArrayList(t));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsubList.add(t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}"}, {"code": "@Bean\n\t@ConditionalOnMissingBean(PreDecorationFilter.class)\n\tpublic PreDecorationFilter preDecorationFilter(RouteLocator routeLocator,\n\t\t\tProxyRequestHelper proxyRequestHelper) {\n\t\treturn new PreDecorationFilter(routeLocator,\n\t\t\t\tthis.server.getServlet().getContextPath(), this.zuulProperties,\n\t\t\t\tproxyRequestHelper);\n\t}", "code_tokens": ["@", "Bean", "@", "ConditionalOnMissingBean", "(", "PreDecorationFilter", ".", "class", ")", "public", "PreDecorationFilter", "preDecorationFilter", "(", "RouteLocator", "routeLocator", ",", "ProxyRequestHelper", "proxyRequestHelper", ")", "{", "return", "new", "PreDecorationFilter", "(", "routeLocator", ",", "this", ".", "server", ".", "getServlet", "(", ")", ".", "getContextPath", "(", ")", ",", "this", ".", "zuulProperties", ",", "proxyRequestHelper", ")", ";", "}"], "original_string": "@Bean\n\t@ConditionalOnMissingBean(PreDecorationFilter.class)\n\tpublic PreDecorationFilter preDecorationFilter(RouteLocator routeLocator,\n\t\t\tProxyRequestHelper proxyRequestHelper) {\n\t\treturn new PreDecorationFilter(routeLocator,\n\t\t\t\tthis.server.getServlet().getContextPath(), this.zuulProperties,\n\t\t\t\tproxyRequestHelper);\n\t}"}, {"code": "@Override\n    public void recognition(Term[] terms) {\n        this.terms = terms;\n        List<Term> termList = recogntion_();\n        for (Term term2 : termList) {\n            TermUtil.insertTerm(terms, term2, InsertTermType.SCORE_ADD_SORT);\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "recognition", "(", "Term", "[", "]", "terms", ")", "{", "this", ".", "terms", "=", "terms", ";", "List", "<", "Term", ">", "termList", "=", "recogntion_", "(", ")", ";", "for", "(", "Term", "term2", ":", "termList", ")", "{", "TermUtil", ".", "insertTerm", "(", "terms", ",", "term2", ",", "InsertTermType", ".", "SCORE_ADD_SORT", ")", ";", "}", "}"], "original_string": "@Override\n    public void recognition(Term[] terms) {\n        this.terms = terms;\n        List<Term> termList = recogntion_();\n        for (Term term2 : termList) {\n            TermUtil.insertTerm(terms, term2, InsertTermType.SCORE_ADD_SORT);\n        }\n    }"}, {"code": "public boolean isMatchingTopic(String topic) {\n\t\tif (isFixedTopics()) {\n\t\t\treturn getFixedTopics().contains(topic);\n\t\t} else {\n\t\t\treturn topicPattern.matcher(topic).matches();\n\t\t}\n\t}", "code_tokens": ["public", "boolean", "isMatchingTopic", "(", "String", "topic", ")", "{", "if", "(", "isFixedTopics", "(", ")", ")", "{", "return", "getFixedTopics", "(", ")", ".", "contains", "(", "topic", ")", ";", "}", "else", "{", "return", "topicPattern", ".", "matcher", "(", "topic", ")", ".", "matches", "(", ")", ";", "}", "}"], "original_string": "public boolean isMatchingTopic(String topic) {\n\t\tif (isFixedTopics()) {\n\t\t\treturn getFixedTopics().contains(topic);\n\t\t} else {\n\t\t\treturn topicPattern.matcher(topic).matches();\n\t\t}\n\t}"}, {"code": "public static <K, V> MergeResult<K, V> mergeRightIntoLeft(LinkedOptionalMap<K, V> left, LinkedOptionalMap<K, V> right) {\n\t\tLinkedOptionalMap<K, V> merged = new LinkedOptionalMap<>(left);\n\t\tmerged.putAll(right);\n\n\t\treturn new MergeResult<>(merged, isLeftPrefixOfRight(left, right));\n\t}", "code_tokens": ["public", "static", "<", "K", ",", "V", ">", "MergeResult", "<", "K", ",", "V", ">", "mergeRightIntoLeft", "(", "LinkedOptionalMap", "<", "K", ",", "V", ">", "left", ",", "LinkedOptionalMap", "<", "K", ",", "V", ">", "right", ")", "{", "LinkedOptionalMap", "<", "K", ",", "V", ">", "merged", "=", "new", "LinkedOptionalMap", "<>", "(", "left", ")", ";", "merged", ".", "putAll", "(", "right", ")", ";", "return", "new", "MergeResult", "<>", "(", "merged", ",", "isLeftPrefixOfRight", "(", "left", ",", "right", ")", ")", ";", "}"], "original_string": "public static <K, V> MergeResult<K, V> mergeRightIntoLeft(LinkedOptionalMap<K, V> left, LinkedOptionalMap<K, V> right) {\n\t\tLinkedOptionalMap<K, V> merged = new LinkedOptionalMap<>(left);\n\t\tmerged.putAll(right);\n\n\t\treturn new MergeResult<>(merged, isLeftPrefixOfRight(left, right));\n\t}"}, {"code": "public static Method getMethodByName(Class<?> clazz, boolean ignoreCase, String methodName) throws SecurityException {\r\n\t\tif (null == clazz || StrUtil.isBlank(methodName)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tfinal Method[] methods = getMethods(clazz);\r\n\t\tif (ArrayUtil.isNotEmpty(methods)) {\r\n\t\t\tfor (Method method : methods) {\r\n\t\t\t\tif (StrUtil.equals(methodName, method.getName(), ignoreCase)) {\r\n\t\t\t\t\treturn method;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}", "code_tokens": ["public", "static", "Method", "getMethodByName", "(", "Class", "<", "?", ">", "clazz", ",", "boolean", "ignoreCase", ",", "String", "methodName", ")", "throws", "SecurityException", "{", "if", "(", "null", "==", "clazz", "||", "StrUtil", ".", "isBlank", "(", "methodName", ")", ")", "{", "return", "null", ";", "}", "final", "Method", "[", "]", "methods", "=", "getMethods", "(", "clazz", ")", ";", "if", "(", "ArrayUtil", ".", "isNotEmpty", "(", "methods", ")", ")", "{", "for", "(", "Method", "method", ":", "methods", ")", "{", "if", "(", "StrUtil", ".", "equals", "(", "methodName", ",", "method", ".", "getName", "(", ")", ",", "ignoreCase", ")", ")", "{", "return", "method", ";", "}", "}", "}", "return", "null", ";", "}"], "original_string": "public static Method getMethodByName(Class<?> clazz, boolean ignoreCase, String methodName) throws SecurityException {\r\n\t\tif (null == clazz || StrUtil.isBlank(methodName)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tfinal Method[] methods = getMethods(clazz);\r\n\t\tif (ArrayUtil.isNotEmpty(methods)) {\r\n\t\t\tfor (Method method : methods) {\r\n\t\t\t\tif (StrUtil.equals(methodName, method.getName(), ignoreCase)) {\r\n\t\t\t\t\treturn method;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}"}, {"code": "@SuppressWarnings(\"unchecked\")\n\t@PublicEvolving\n\tpublic static <T, C> ObjectArrayTypeInfo<T, C> getInfoFor(TypeInformation<C> componentInfo) {\n\t\tcheckNotNull(componentInfo);\n\n\t\treturn new ObjectArrayTypeInfo<T, C>(\n\t\t\t(Class<T>)Array.newInstance(componentInfo.getTypeClass(), 0).getClass(),\n\t\t\tcomponentInfo);\n\t}", "code_tokens": ["@", "SuppressWarnings", "(", "\"unchecked\"", ")", "@", "PublicEvolving", "public", "static", "<", "T", ",", "C", ">", "ObjectArrayTypeInfo", "<", "T", ",", "C", ">", "getInfoFor", "(", "TypeInformation", "<", "C", ">", "componentInfo", ")", "{", "checkNotNull", "(", "componentInfo", ")", ";", "return", "new", "ObjectArrayTypeInfo", "<", "T", ",", "C", ">", "(", "(", "Class", "<", "T", ">", ")", "Array", ".", "newInstance", "(", "componentInfo", ".", "getTypeClass", "(", ")", ",", "0", ")", ".", "getClass", "(", ")", ",", "componentInfo", ")", ";", "}"], "original_string": "@SuppressWarnings(\"unchecked\")\n\t@PublicEvolving\n\tpublic static <T, C> ObjectArrayTypeInfo<T, C> getInfoFor(TypeInformation<C> componentInfo) {\n\t\tcheckNotNull(componentInfo);\n\n\t\treturn new ObjectArrayTypeInfo<T, C>(\n\t\t\t(Class<T>)Array.newInstance(componentInfo.getTypeClass(), 0).getClass(),\n\t\t\tcomponentInfo);\n\t}"}, {"code": "@Override\n\tpublic void processElement1(StreamRecord<T1> record) throws Exception {\n\t\tprocessElement(record, leftBuffer, rightBuffer, lowerBound, upperBound, true);\n\t}", "code_tokens": ["@", "Override", "public", "void", "processElement1", "(", "StreamRecord", "<", "T1", ">", "record", ")", "throws", "Exception", "{", "processElement", "(", "record", ",", "leftBuffer", ",", "rightBuffer", ",", "lowerBound", ",", "upperBound", ",", "true", ")", ";", "}"], "original_string": "@Override\n\tpublic void processElement1(StreamRecord<T1> record) throws Exception {\n\t\tprocessElement(record, leftBuffer, rightBuffer, lowerBound, upperBound, true);\n\t}"}, {"code": "private void failTask(final ExecutionAttemptID executionAttemptID, final Throwable cause) {\n\t\tfinal Task task = taskSlotTable.getTask(executionAttemptID);\n\n\t\tif (task != null) {\n\t\t\ttry {\n\t\t\t\ttask.failExternally(cause);\n\t\t\t} catch (Throwable t) {\n\t\t\t\tlog.error(\"Could not fail task {}.\", executionAttemptID, t);\n\t\t\t}\n\t\t} else {\n\t\t\tlog.debug(\"Cannot find task to fail for execution {}.\", executionAttemptID);\n\t\t}\n\t}", "code_tokens": ["private", "void", "failTask", "(", "final", "ExecutionAttemptID", "executionAttemptID", ",", "final", "Throwable", "cause", ")", "{", "final", "Task", "task", "=", "taskSlotTable", ".", "getTask", "(", "executionAttemptID", ")", ";", "if", "(", "task", "!=", "null", ")", "{", "try", "{", "task", ".", "failExternally", "(", "cause", ")", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "log", ".", "error", "(", "\"Could not fail task {}.\"", ",", "executionAttemptID", ",", "t", ")", ";", "}", "}", "else", "{", "log", ".", "debug", "(", "\"Cannot find task to fail for execution {}.\"", ",", "executionAttemptID", ")", ";", "}", "}"], "original_string": "private void failTask(final ExecutionAttemptID executionAttemptID, final Throwable cause) {\n\t\tfinal Task task = taskSlotTable.getTask(executionAttemptID);\n\n\t\tif (task != null) {\n\t\t\ttry {\n\t\t\t\ttask.failExternally(cause);\n\t\t\t} catch (Throwable t) {\n\t\t\t\tlog.error(\"Could not fail task {}.\", executionAttemptID, t);\n\t\t\t}\n\t\t} else {\n\t\t\tlog.debug(\"Cannot find task to fail for execution {}.\", executionAttemptID);\n\t\t}\n\t}"}, {"code": "public static Validation<String> moreThan(int size, String msg) {\n        return notEmpty().and(SimpleValidation.from((s) -> s.length() >= size, format(msg, size)));\n    }", "code_tokens": ["public", "static", "Validation", "<", "String", ">", "moreThan", "(", "int", "size", ",", "String", "msg", ")", "{", "return", "notEmpty", "(", ")", ".", "and", "(", "SimpleValidation", ".", "from", "(", "(", "s", ")", "-", ">", "s", ".", "length", "(", ")", ">=", "size", ",", "format", "(", "msg", ",", "size", ")", ")", ")", ";", "}"], "original_string": "public static Validation<String> moreThan(int size, String msg) {\n        return notEmpty().and(SimpleValidation.from((s) -> s.length() >= size, format(msg, size)));\n    }"}, {"code": "private boolean openTagSet(String filename)\n    {\n        int max_size = 0;\n        InputStreamReader isr = null;\n        y_.clear();\n        try\n        {\n            isr = new InputStreamReader(IOUtil.newInputStream(filename), \"UTF-8\");\n            BufferedReader br = new BufferedReader(isr);\n            String line;\n            while ((line = br.readLine()) != null)\n            {\n                if (line.length() == 0)\n                {\n                    continue;\n                }\n                char firstChar = line.charAt(0);\n                if (firstChar == '\\0' || firstChar == ' ' || firstChar == '\\t')\n                {\n                    continue;\n                }\n                String[] cols = line.split(\"[\\t ]\", -1);\n                if (max_size == 0)\n                {\n                    max_size = cols.length;\n                }\n                if (max_size != cols.length)\n                {\n                    String msg = \"inconsistent column size: \" + max_size +\n                        \" \" + cols.length + \" \" + filename;\n                    throw new RuntimeException(msg);\n                }\n                xsize_ = cols.length - 1;\n                if (y_.indexOf(cols[max_size - 1]) == -1)\n                {\n                    y_.add(cols[max_size - 1]);\n                }\n            }\n            Collections.sort(y_);\n            br.close();\n        }\n        catch (Exception e)\n        {\n            if (isr != null)\n            {\n                try\n                {\n                    isr.close();\n                }\n                catch (Exception e2)\n                {\n                }\n            }\n            e.printStackTrace();\n            System.err.println(\"Error reading \" + filename);\n            return false;\n        }\n        return true;\n    }", "code_tokens": ["private", "boolean", "openTagSet", "(", "String", "filename", ")", "{", "int", "max_size", "=", "0", ";", "InputStreamReader", "isr", "=", "null", ";", "y_", ".", "clear", "(", ")", ";", "try", "{", "isr", "=", "new", "InputStreamReader", "(", "IOUtil", ".", "newInputStream", "(", "filename", ")", ",", "\"UTF-8\"", ")", ";", "BufferedReader", "br", "=", "new", "BufferedReader", "(", "isr", ")", ";", "String", "line", ";", "while", "(", "(", "line", "=", "br", ".", "readLine", "(", ")", ")", "!=", "null", ")", "{", "if", "(", "line", ".", "length", "(", ")", "==", "0", ")", "{", "continue", ";", "}", "char", "firstChar", "=", "line", ".", "charAt", "(", "0", ")", ";", "if", "(", "firstChar", "==", "'", "'", "||", "firstChar", "==", "'", "'", "||", "firstChar", "==", "'", "'", ")", "{", "continue", ";", "}", "String", "[", "]", "cols", "=", "line", ".", "split", "(", "\"[\\t ]\"", ",", "-", "1", ")", ";", "if", "(", "max_size", "==", "0", ")", "{", "max_size", "=", "cols", ".", "length", ";", "}", "if", "(", "max_size", "!=", "cols", ".", "length", ")", "{", "String", "msg", "=", "\"inconsistent column size: \"", "+", "max_size", "+", "\" \"", "+", "cols", ".", "length", "+", "\" \"", "+", "filename", ";", "throw", "new", "RuntimeException", "(", "msg", ")", ";", "}", "xsize_", "=", "cols", ".", "length", "-", "1", ";", "if", "(", "y_", ".", "indexOf", "(", "cols", "[", "max_size", "-", "1", "]", ")", "==", "-", "1", ")", "{", "y_", ".", "add", "(", "cols", "[", "max_size", "-", "1", "]", ")", ";", "}", "}", "Collections", ".", "sort", "(", "y_", ")", ";", "br", ".", "close", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "if", "(", "isr", "!=", "null", ")", "{", "try", "{", "isr", ".", "close", "(", ")", ";", "}", "catch", "(", "Exception", "e2", ")", "{", "}", "}", "e", ".", "printStackTrace", "(", ")", ";", "System", ".", "err", ".", "println", "(", "\"Error reading \"", "+", "filename", ")", ";", "return", "false", ";", "}", "return", "true", ";", "}"], "original_string": "private boolean openTagSet(String filename)\n    {\n        int max_size = 0;\n        InputStreamReader isr = null;\n        y_.clear();\n        try\n        {\n            isr = new InputStreamReader(IOUtil.newInputStream(filename), \"UTF-8\");\n            BufferedReader br = new BufferedReader(isr);\n            String line;\n            while ((line = br.readLine()) != null)\n            {\n                if (line.length() == 0)\n                {\n                    continue;\n                }\n                char firstChar = line.charAt(0);\n                if (firstChar == '\\0' || firstChar == ' ' || firstChar == '\\t')\n                {\n                    continue;\n                }\n                String[] cols = line.split(\"[\\t ]\", -1);\n                if (max_size == 0)\n                {\n                    max_size = cols.length;\n                }\n                if (max_size != cols.length)\n                {\n                    String msg = \"inconsistent column size: \" + max_size +\n                        \" \" + cols.length + \" \" + filename;\n                    throw new RuntimeException(msg);\n                }\n                xsize_ = cols.length - 1;\n                if (y_.indexOf(cols[max_size - 1]) == -1)\n                {\n                    y_.add(cols[max_size - 1]);\n                }\n            }\n            Collections.sort(y_);\n            br.close();\n        }\n        catch (Exception e)\n        {\n            if (isr != null)\n            {\n                try\n                {\n                    isr.close();\n                }\n                catch (Exception e2)\n                {\n                }\n            }\n            e.printStackTrace();\n            System.err.println(\"Error reading \" + filename);\n            return false;\n        }\n        return true;\n    }"}, {"code": "public static <T> Iterator<T> removeNull(final Iterator<T> itr) {\n        return com.google.common.collect.Iterators.filter(itr, Predicates.notNull());\n    }", "code_tokens": ["public", "static", "<", "T", ">", "Iterator", "<", "T", ">", "removeNull", "(", "final", "Iterator", "<", "T", ">", "itr", ")", "{", "return", "com", ".", "google", ".", "common", ".", "collect", ".", "Iterators", ".", "filter", "(", "itr", ",", "Predicates", ".", "notNull", "(", ")", ")", ";", "}"], "original_string": "public static <T> Iterator<T> removeNull(final Iterator<T> itr) {\n        return com.google.common.collect.Iterators.filter(itr, Predicates.notNull());\n    }"}, {"code": "@Override\n\tpublic void setup(AbstractInvokable parent) {\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tfinal ReduceFunction<IT> red = BatchTask.instantiateUserCode(this.config, userCodeClassLoader, ReduceFunction.class);\n\t\tthis.reducer = red;\n\t\tFunctionUtils.setFunctionRuntimeContext(red, getUdfRuntimeContext());\n\n\t\tTypeSerializerFactory<IT> serializerFactory = this.config.getInputSerializer(0, userCodeClassLoader);\n\t\tthis.serializer = serializerFactory.getSerializer();\n\n\t\tif (LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"ChainedAllReduceDriver object reuse: \" + (this.objectReuseEnabled ? \"ENABLED\" : \"DISABLED\") + \".\");\n\t\t}\n\t}", "code_tokens": ["@", "Override", "public", "void", "setup", "(", "AbstractInvokable", "parent", ")", "{", "@", "SuppressWarnings", "(", "\"unchecked\"", ")", "final", "ReduceFunction", "<", "IT", ">", "red", "=", "BatchTask", ".", "instantiateUserCode", "(", "this", ".", "config", ",", "userCodeClassLoader", ",", "ReduceFunction", ".", "class", ")", ";", "this", ".", "reducer", "=", "red", ";", "FunctionUtils", ".", "setFunctionRuntimeContext", "(", "red", ",", "getUdfRuntimeContext", "(", ")", ")", ";", "TypeSerializerFactory", "<", "IT", ">", "serializerFactory", "=", "this", ".", "config", ".", "getInputSerializer", "(", "0", ",", "userCodeClassLoader", ")", ";", "this", ".", "serializer", "=", "serializerFactory", ".", "getSerializer", "(", ")", ";", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "{", "LOG", ".", "debug", "(", "\"ChainedAllReduceDriver object reuse: \"", "+", "(", "this", ".", "objectReuseEnabled", "?", "\"ENABLED\"", ":", "\"DISABLED\"", ")", "+", "\".\"", ")", ";", "}", "}"], "original_string": "@Override\n\tpublic void setup(AbstractInvokable parent) {\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tfinal ReduceFunction<IT> red = BatchTask.instantiateUserCode(this.config, userCodeClassLoader, ReduceFunction.class);\n\t\tthis.reducer = red;\n\t\tFunctionUtils.setFunctionRuntimeContext(red, getUdfRuntimeContext());\n\n\t\tTypeSerializerFactory<IT> serializerFactory = this.config.getInputSerializer(0, userCodeClassLoader);\n\t\tthis.serializer = serializerFactory.getSerializer();\n\n\t\tif (LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"ChainedAllReduceDriver object reuse: \" + (this.objectReuseEnabled ? \"ENABLED\" : \"DISABLED\") + \".\");\n\t\t}\n\t}"}, {"code": "@CheckForNull\n    public static Number tryParseNumber(@CheckForNull String numberStr, @CheckForNull Number defaultNumber) {\n        if ((numberStr == null) || (numberStr.length() == 0)) {\n            return defaultNumber;\n        }\n        try {\n            return NumberFormat.getNumberInstance().parse(numberStr);\n        } catch (ParseException e) {\n            return defaultNumber;\n        }\n    }", "code_tokens": ["@", "CheckForNull", "public", "static", "Number", "tryParseNumber", "(", "@", "CheckForNull", "String", "numberStr", ",", "@", "CheckForNull", "Number", "defaultNumber", ")", "{", "if", "(", "(", "numberStr", "==", "null", ")", "||", "(", "numberStr", ".", "length", "(", ")", "==", "0", ")", ")", "{", "return", "defaultNumber", ";", "}", "try", "{", "return", "NumberFormat", ".", "getNumberInstance", "(", ")", ".", "parse", "(", "numberStr", ")", ";", "}", "catch", "(", "ParseException", "e", ")", "{", "return", "defaultNumber", ";", "}", "}"], "original_string": "@CheckForNull\n    public static Number tryParseNumber(@CheckForNull String numberStr, @CheckForNull Number defaultNumber) {\n        if ((numberStr == null) || (numberStr.length() == 0)) {\n            return defaultNumber;\n        }\n        try {\n            return NumberFormat.getNumberInstance().parse(numberStr);\n        } catch (ParseException e) {\n            return defaultNumber;\n        }\n    }"}, {"code": "public void beginType(String type, String kind, int modifiers) throws IOException {\n    beginType(type, kind, modifiers, null);\n  }", "code_tokens": ["public", "void", "beginType", "(", "String", "type", ",", "String", "kind", ",", "int", "modifiers", ")", "throws", "IOException", "{", "beginType", "(", "type", ",", "kind", ",", "modifiers", ",", "null", ")", ";", "}"], "original_string": "public void beginType(String type, String kind, int modifiers) throws IOException {\n    beginType(type, kind, modifiers, null);\n  }"}, {"code": "public void evictConnection(Connection connection)\n   {\n      HikariPool p;\n      if (!isClosed() && (p = pool) != null && connection.getClass().getName().startsWith(\"com.zaxxer.hikari\")) {\n         p.evictConnection(connection);\n      }\n   }", "code_tokens": ["public", "void", "evictConnection", "(", "Connection", "connection", ")", "{", "HikariPool", "p", ";", "if", "(", "!", "isClosed", "(", ")", "&&", "(", "p", "=", "pool", ")", "!=", "null", "&&", "connection", ".", "getClass", "(", ")", ".", "getName", "(", ")", ".", "startsWith", "(", "\"com.zaxxer.hikari\"", ")", ")", "{", "p", ".", "evictConnection", "(", "connection", ")", ";", "}", "}"], "original_string": "public void evictConnection(Connection connection)\n   {\n      HikariPool p;\n      if (!isClosed() && (p = pool) != null && connection.getClass().getName().startsWith(\"com.zaxxer.hikari\")) {\n         p.evictConnection(connection);\n      }\n   }"}, {"code": "public FilterOperator<T> filter(FilterFunction<T> filter) {\n\t\tif (filter == null) {\n\t\t\tthrow new NullPointerException(\"Filter function must not be null.\");\n\t\t}\n\t\treturn new FilterOperator<>(this, clean(filter), Utils.getCallLocationName());\n\t}", "code_tokens": ["public", "FilterOperator", "<", "T", ">", "filter", "(", "FilterFunction", "<", "T", ">", "filter", ")", "{", "if", "(", "filter", "==", "null", ")", "{", "throw", "new", "NullPointerException", "(", "\"Filter function must not be null.\"", ")", ";", "}", "return", "new", "FilterOperator", "<>", "(", "this", ",", "clean", "(", "filter", ")", ",", "Utils", ".", "getCallLocationName", "(", ")", ")", ";", "}"], "original_string": "public FilterOperator<T> filter(FilterFunction<T> filter) {\n\t\tif (filter == null) {\n\t\t\tthrow new NullPointerException(\"Filter function must not be null.\");\n\t\t}\n\t\treturn new FilterOperator<>(this, clean(filter), Utils.getCallLocationName());\n\t}"}, {"code": "@ExperimentalApi(\"https://github.com/grpc/grpc-java/issues/4477\")\n  public static <T extends Message> Metadata.BinaryMarshaller<T> metadataMarshaller(T instance) {\n    return ProtoLiteUtils.metadataMarshaller(instance);\n  }", "code_tokens": ["@", "ExperimentalApi", "(", "\"https://github.com/grpc/grpc-java/issues/4477\"", ")", "public", "static", "<", "T", "extends", "Message", ">", "Metadata", ".", "BinaryMarshaller", "<", "T", ">", "metadataMarshaller", "(", "T", "instance", ")", "{", "return", "ProtoLiteUtils", ".", "metadataMarshaller", "(", "instance", ")", ";", "}"], "original_string": "@ExperimentalApi(\"https://github.com/grpc/grpc-java/issues/4477\")\n  public static <T extends Message> Metadata.BinaryMarshaller<T> metadataMarshaller(T instance) {\n    return ProtoLiteUtils.metadataMarshaller(instance);\n  }"}, {"code": "protected ResponseEntity<String> createResponseEntityForTicket(final HttpServletRequest request,\n                                                                   final TicketGrantingTicket tgtId) throws Exception {\n        return this.ticketGrantingTicketResourceEntityResponseFactory.build(tgtId, request);\n    }", "code_tokens": ["protected", "ResponseEntity", "<", "String", ">", "createResponseEntityForTicket", "(", "final", "HttpServletRequest", "request", ",", "final", "TicketGrantingTicket", "tgtId", ")", "throws", "Exception", "{", "return", "this", ".", "ticketGrantingTicketResourceEntityResponseFactory", ".", "build", "(", "tgtId", ",", "request", ")", ";", "}"], "original_string": "protected ResponseEntity<String> createResponseEntityForTicket(final HttpServletRequest request,\n                                                                   final TicketGrantingTicket tgtId) throws Exception {\n        return this.ticketGrantingTicketResourceEntityResponseFactory.build(tgtId, request);\n    }"}, {"code": "protected void createServiceWarningViewState(final Flow flow) {\n        val stateWarning = createViewState(flow, CasWebflowConstants.STATE_ID_SHOW_WARNING_VIEW, CasWebflowConstants.VIEW_ID_CONFIRM);\n        createTransitionForState(stateWarning, CasWebflowConstants.TRANSITION_ID_SUCCESS, \"finalizeWarning\");\n        val finalizeWarn = createActionState(flow, \"finalizeWarning\", createEvaluateAction(\"serviceWarningAction\"));\n        createTransitionForState(finalizeWarn, CasWebflowConstants.STATE_ID_REDIRECT, CasWebflowConstants.STATE_ID_REDIRECT);\n    }", "code_tokens": ["protected", "void", "createServiceWarningViewState", "(", "final", "Flow", "flow", ")", "{", "val", "stateWarning", "=", "createViewState", "(", "flow", ",", "CasWebflowConstants", ".", "STATE_ID_SHOW_WARNING_VIEW", ",", "CasWebflowConstants", ".", "VIEW_ID_CONFIRM", ")", ";", "createTransitionForState", "(", "stateWarning", ",", "CasWebflowConstants", ".", "TRANSITION_ID_SUCCESS", ",", "\"finalizeWarning\"", ")", ";", "val", "finalizeWarn", "=", "createActionState", "(", "flow", ",", "\"finalizeWarning\"", ",", "createEvaluateAction", "(", "\"serviceWarningAction\"", ")", ")", ";", "createTransitionForState", "(", "finalizeWarn", ",", "CasWebflowConstants", ".", "STATE_ID_REDIRECT", ",", "CasWebflowConstants", ".", "STATE_ID_REDIRECT", ")", ";", "}"], "original_string": "protected void createServiceWarningViewState(final Flow flow) {\n        val stateWarning = createViewState(flow, CasWebflowConstants.STATE_ID_SHOW_WARNING_VIEW, CasWebflowConstants.VIEW_ID_CONFIRM);\n        createTransitionForState(stateWarning, CasWebflowConstants.TRANSITION_ID_SUCCESS, \"finalizeWarning\");\n        val finalizeWarn = createActionState(flow, \"finalizeWarning\", createEvaluateAction(\"serviceWarningAction\"));\n        createTransitionForState(finalizeWarn, CasWebflowConstants.STATE_ID_REDIRECT, CasWebflowConstants.STATE_ID_REDIRECT);\n    }"}, {"code": "public static int elementWiseStride(IntBuffer buffer) {\n        int length2 = shapeInfoLength(buffer.get(0));\n        return buffer.get(length2 - 2);\n    }", "code_tokens": ["public", "static", "int", "elementWiseStride", "(", "IntBuffer", "buffer", ")", "{", "int", "length2", "=", "shapeInfoLength", "(", "buffer", ".", "get", "(", "0", ")", ")", ";", "return", "buffer", ".", "get", "(", "length2", "-", "2", ")", ";", "}"], "original_string": "public static int elementWiseStride(IntBuffer buffer) {\n        int length2 = shapeInfoLength(buffer.get(0));\n        return buffer.get(length2 - 2);\n    }"}, {"code": "public static byte getSerializeTypeByContentType(String contentType) throws SofaRpcException {\n        if (StringUtils.isNotBlank(contentType)) {\n            String ct = contentType.toLowerCase();\n            if (ct.contains(\"text/plain\") || ct.contains(\"text/html\") || ct.contains(\"application/json\")) {\n                return getSerializeTypeByName(RpcConstants.SERIALIZE_JSON);\n            } else if (ct.contains(RpcConstants.SERIALIZE_PROTOBUF)) {\n                return getSerializeTypeByName(RpcConstants.SERIALIZE_PROTOBUF);\n            } else if (ct.contains(RpcConstants.SERIALIZE_HESSIAN)) {\n                return getSerializeTypeByName(RpcConstants.SERIALIZE_HESSIAN2);\n            }\n        }\n        throw new SofaRpcException(RpcErrorType.SERVER_DESERIALIZE, \"Unsupported content type \" + contentType\n            + \" in http protocol, please set HTTP HEAD: '\" + RemotingConstants.HEAD_SERIALIZE_TYPE + \"'.\");\n    }", "code_tokens": ["public", "static", "byte", "getSerializeTypeByContentType", "(", "String", "contentType", ")", "throws", "SofaRpcException", "{", "if", "(", "StringUtils", ".", "isNotBlank", "(", "contentType", ")", ")", "{", "String", "ct", "=", "contentType", ".", "toLowerCase", "(", ")", ";", "if", "(", "ct", ".", "contains", "(", "\"text/plain\"", ")", "||", "ct", ".", "contains", "(", "\"text/html\"", ")", "||", "ct", ".", "contains", "(", "\"application/json\"", ")", ")", "{", "return", "getSerializeTypeByName", "(", "RpcConstants", ".", "SERIALIZE_JSON", ")", ";", "}", "else", "if", "(", "ct", ".", "contains", "(", "RpcConstants", ".", "SERIALIZE_PROTOBUF", ")", ")", "{", "return", "getSerializeTypeByName", "(", "RpcConstants", ".", "SERIALIZE_PROTOBUF", ")", ";", "}", "else", "if", "(", "ct", ".", "contains", "(", "RpcConstants", ".", "SERIALIZE_HESSIAN", ")", ")", "{", "return", "getSerializeTypeByName", "(", "RpcConstants", ".", "SERIALIZE_HESSIAN2", ")", ";", "}", "}", "throw", "new", "SofaRpcException", "(", "RpcErrorType", ".", "SERVER_DESERIALIZE", ",", "\"Unsupported content type \"", "+", "contentType", "+", "\" in http protocol, please set HTTP HEAD: '\"", "+", "RemotingConstants", ".", "HEAD_SERIALIZE_TYPE", "+", "\"'.\"", ")", ";", "}"], "original_string": "public static byte getSerializeTypeByContentType(String contentType) throws SofaRpcException {\n        if (StringUtils.isNotBlank(contentType)) {\n            String ct = contentType.toLowerCase();\n            if (ct.contains(\"text/plain\") || ct.contains(\"text/html\") || ct.contains(\"application/json\")) {\n                return getSerializeTypeByName(RpcConstants.SERIALIZE_JSON);\n            } else if (ct.contains(RpcConstants.SERIALIZE_PROTOBUF)) {\n                return getSerializeTypeByName(RpcConstants.SERIALIZE_PROTOBUF);\n            } else if (ct.contains(RpcConstants.SERIALIZE_HESSIAN)) {\n                return getSerializeTypeByName(RpcConstants.SERIALIZE_HESSIAN2);\n            }\n        }\n        throw new SofaRpcException(RpcErrorType.SERVER_DESERIALIZE, \"Unsupported content type \" + contentType\n            + \" in http protocol, please set HTTP HEAD: '\" + RemotingConstants.HEAD_SERIALIZE_TYPE + \"'.\");\n    }"}, {"code": "public static <ReqT, RespT> ListenableFuture<RespT> futureUnaryCall(\n      ClientCall<ReqT, RespT> call, ReqT req) {\n    GrpcFuture<RespT> responseFuture = new GrpcFuture<>(call);\n    asyncUnaryRequestCall(call, req, new UnaryStreamToFuture<>(responseFuture), false);\n    return responseFuture;\n  }", "code_tokens": ["public", "static", "<", "ReqT", ",", "RespT", ">", "ListenableFuture", "<", "RespT", ">", "futureUnaryCall", "(", "ClientCall", "<", "ReqT", ",", "RespT", ">", "call", ",", "ReqT", "req", ")", "{", "GrpcFuture", "<", "RespT", ">", "responseFuture", "=", "new", "GrpcFuture", "<>", "(", "call", ")", ";", "asyncUnaryRequestCall", "(", "call", ",", "req", ",", "new", "UnaryStreamToFuture", "<>", "(", "responseFuture", ")", ",", "false", ")", ";", "return", "responseFuture", ";", "}"], "original_string": "public static <ReqT, RespT> ListenableFuture<RespT> futureUnaryCall(\n      ClientCall<ReqT, RespT> call, ReqT req) {\n    GrpcFuture<RespT> responseFuture = new GrpcFuture<>(call);\n    asyncUnaryRequestCall(call, req, new UnaryStreamToFuture<>(responseFuture), false);\n    return responseFuture;\n  }"}, {"code": "private HttpURLConnection openHttp() throws IOException {\r\n\t\tfinal URLConnection conn = openConnection();\r\n\t\tif (false == conn instanceof HttpURLConnection) {\r\n\t\t\t// \u9632\u6b62\u5176\u5b83\u534f\u8bae\u9020\u6210\u7684\u8f6c\u6362\u5f02\u5e38\r\n\t\t\tthrow new HttpException(\"'{}' is not a http connection, make sure URL is format for http.\", conn.getClass().getName());\r\n\t\t}\r\n\r\n\t\treturn (HttpURLConnection) conn;\r\n\t}", "code_tokens": ["private", "HttpURLConnection", "openHttp", "(", ")", "throws", "IOException", "{", "final", "URLConnection", "conn", "=", "openConnection", "(", ")", ";", "if", "(", "false", "==", "conn", "instanceof", "HttpURLConnection", ")", "{", "// \u9632\u6b62\u5176\u5b83\u534f\u8bae\u9020\u6210\u7684\u8f6c\u6362\u5f02\u5e38\r", "throw", "new", "HttpException", "(", "\"'{}' is not a http connection, make sure URL is format for http.\"", ",", "conn", ".", "getClass", "(", ")", ".", "getName", "(", ")", ")", ";", "}", "return", "(", "HttpURLConnection", ")", "conn", ";", "}"], "original_string": "private HttpURLConnection openHttp() throws IOException {\r\n\t\tfinal URLConnection conn = openConnection();\r\n\t\tif (false == conn instanceof HttpURLConnection) {\r\n\t\t\t// \u9632\u6b62\u5176\u5b83\u534f\u8bae\u9020\u6210\u7684\u8f6c\u6362\u5f02\u5e38\r\n\t\t\tthrow new HttpException(\"'{}' is not a http connection, make sure URL is format for http.\", conn.getClass().getName());\r\n\t\t}\r\n\r\n\t\treturn (HttpURLConnection) conn;\r\n\t}"}, {"code": "public MultiLayerConfiguration getMultiLayerConfiguration()\n            throws InvalidKerasConfigurationException, UnsupportedKerasConfigurationException {\n        if (!this.className.equals(config.getFieldClassNameSequential()))\n            throw new InvalidKerasConfigurationException(\n                    \"Keras model class name \" + this.className + \" incompatible with MultiLayerNetwork\");\n        if (this.inputLayerNames.size() != 1)\n            throw new InvalidKerasConfigurationException(\n                    \"MultiLayerNetwork expects only 1 input (found \" + this.inputLayerNames.size() + \")\");\n        if (this.outputLayerNames.size() != 1)\n            throw new InvalidKerasConfigurationException(\n                    \"MultiLayerNetwork expects only 1 output (found \" + this.outputLayerNames.size() + \")\");\n\n        NeuralNetConfiguration.Builder modelBuilder = new NeuralNetConfiguration.Builder();\n\n        if (optimizer != null) {\n            modelBuilder.updater(optimizer);\n        }\n\n        NeuralNetConfiguration.ListBuilder listBuilder = modelBuilder.list();\n\n        /* Add layers one at a time. */\n        KerasLayer prevLayer = null;\n        int layerIndex = 0;\n        for (KerasLayer layer : this.layersOrdered) {\n            if (layer.isLayer()) {\n                int nbInbound = layer.getInboundLayerNames().size();\n                if (nbInbound != 1)\n                    throw new InvalidKerasConfigurationException(\n                            \"Layers in MultiLayerConfiguration must have exactly one inbound layer (found \"\n                                    + nbInbound + \" for layer \" + layer.getLayerName() + \")\");\n                if (prevLayer != null) {\n                    InputType[] inputTypes = new InputType[1];\n                    InputPreProcessor preprocessor;\n                    if (prevLayer.isInputPreProcessor()) {\n                        inputTypes[0] = this.outputTypes.get(prevLayer.getInboundLayerNames().get(0));\n                        preprocessor = prevLayer.getInputPreprocessor(inputTypes);\n                    } else {\n                        inputTypes[0] = this.outputTypes.get(prevLayer.getLayerName());\n                        preprocessor = layer.getInputPreprocessor(inputTypes);\n                    }\n                    if (preprocessor != null)\n                        listBuilder.inputPreProcessor(layerIndex, preprocessor);\n                }\n                listBuilder.layer(layerIndex++, layer.getLayer());\n            } else if (layer.getVertex() != null)\n                throw new InvalidKerasConfigurationException(\"Cannot add vertex to MultiLayerConfiguration (class name \"\n                        + layer.getClassName() + \", layer name \" + layer.getLayerName() + \")\");\n            prevLayer = layer;\n        }\n\n        InputType inputType = this.layersOrdered.get(0).getOutputType();\n        if (inputType != null)\n            listBuilder.setInputType(inputType);\n\n        /* Whether to use standard backprop (or BPTT) or truncated BPTT. */\n        if (this.useTruncatedBPTT && this.truncatedBPTT > 0)\n            listBuilder.backpropType(BackpropType.TruncatedBPTT).tBPTTForwardLength(truncatedBPTT)\n                    .tBPTTBackwardLength(truncatedBPTT);\n        else\n            listBuilder.backpropType(BackpropType.Standard);\n        return listBuilder.build();\n    }", "code_tokens": ["public", "MultiLayerConfiguration", "getMultiLayerConfiguration", "(", ")", "throws", "InvalidKerasConfigurationException", ",", "UnsupportedKerasConfigurationException", "{", "if", "(", "!", "this", ".", "className", ".", "equals", "(", "config", ".", "getFieldClassNameSequential", "(", ")", ")", ")", "throw", "new", "InvalidKerasConfigurationException", "(", "\"Keras model class name \"", "+", "this", ".", "className", "+", "\" incompatible with MultiLayerNetwork\"", ")", ";", "if", "(", "this", ".", "inputLayerNames", ".", "size", "(", ")", "!=", "1", ")", "throw", "new", "InvalidKerasConfigurationException", "(", "\"MultiLayerNetwork expects only 1 input (found \"", "+", "this", ".", "inputLayerNames", ".", "size", "(", ")", "+", "\")\"", ")", ";", "if", "(", "this", ".", "outputLayerNames", ".", "size", "(", ")", "!=", "1", ")", "throw", "new", "InvalidKerasConfigurationException", "(", "\"MultiLayerNetwork expects only 1 output (found \"", "+", "this", ".", "outputLayerNames", ".", "size", "(", ")", "+", "\")\"", ")", ";", "NeuralNetConfiguration", ".", "Builder", "modelBuilder", "=", "new", "NeuralNetConfiguration", ".", "Builder", "(", ")", ";", "if", "(", "optimizer", "!=", "null", ")", "{", "modelBuilder", ".", "updater", "(", "optimizer", ")", ";", "}", "NeuralNetConfiguration", ".", "ListBuilder", "listBuilder", "=", "modelBuilder", ".", "list", "(", ")", ";", "/* Add layers one at a time. */", "KerasLayer", "prevLayer", "=", "null", ";", "int", "layerIndex", "=", "0", ";", "for", "(", "KerasLayer", "layer", ":", "this", ".", "layersOrdered", ")", "{", "if", "(", "layer", ".", "isLayer", "(", ")", ")", "{", "int", "nbInbound", "=", "layer", ".", "getInboundLayerNames", "(", ")", ".", "size", "(", ")", ";", "if", "(", "nbInbound", "!=", "1", ")", "throw", "new", "InvalidKerasConfigurationException", "(", "\"Layers in MultiLayerConfiguration must have exactly one inbound layer (found \"", "+", "nbInbound", "+", "\" for layer \"", "+", "layer", ".", "getLayerName", "(", ")", "+", "\")\"", ")", ";", "if", "(", "prevLayer", "!=", "null", ")", "{", "InputType", "[", "]", "inputTypes", "=", "new", "InputType", "[", "1", "]", ";", "InputPreProcessor", "preprocessor", ";", "if", "(", "prevLayer", ".", "isInputPreProcessor", "(", ")", ")", "{", "inputTypes", "[", "0", "]", "=", "this", ".", "outputTypes", ".", "get", "(", "prevLayer", ".", "getInboundLayerNames", "(", ")", ".", "get", "(", "0", ")", ")", ";", "preprocessor", "=", "prevLayer", ".", "getInputPreprocessor", "(", "inputTypes", ")", ";", "}", "else", "{", "inputTypes", "[", "0", "]", "=", "this", ".", "outputTypes", ".", "get", "(", "prevLayer", ".", "getLayerName", "(", ")", ")", ";", "preprocessor", "=", "layer", ".", "getInputPreprocessor", "(", "inputTypes", ")", ";", "}", "if", "(", "preprocessor", "!=", "null", ")", "listBuilder", ".", "inputPreProcessor", "(", "layerIndex", ",", "preprocessor", ")", ";", "}", "listBuilder", ".", "layer", "(", "layerIndex", "++", ",", "layer", ".", "getLayer", "(", ")", ")", ";", "}", "else", "if", "(", "layer", ".", "getVertex", "(", ")", "!=", "null", ")", "throw", "new", "InvalidKerasConfigurationException", "(", "\"Cannot add vertex to MultiLayerConfiguration (class name \"", "+", "layer", ".", "getClassName", "(", ")", "+", "\", layer name \"", "+", "layer", ".", "getLayerName", "(", ")", "+", "\")\"", ")", ";", "prevLayer", "=", "layer", ";", "}", "InputType", "inputType", "=", "this", ".", "layersOrdered", ".", "get", "(", "0", ")", ".", "getOutputType", "(", ")", ";", "if", "(", "inputType", "!=", "null", ")", "listBuilder", ".", "setInputType", "(", "inputType", ")", ";", "/* Whether to use standard backprop (or BPTT) or truncated BPTT. */", "if", "(", "this", ".", "useTruncatedBPTT", "&&", "this", ".", "truncatedBPTT", ">", "0", ")", "listBuilder", ".", "backpropType", "(", "BackpropType", ".", "TruncatedBPTT", ")", ".", "tBPTTForwardLength", "(", "truncatedBPTT", ")", ".", "tBPTTBackwardLength", "(", "truncatedBPTT", ")", ";", "else", "listBuilder", ".", "backpropType", "(", "BackpropType", ".", "Standard", ")", ";", "return", "listBuilder", ".", "build", "(", ")", ";", "}"], "original_string": "public MultiLayerConfiguration getMultiLayerConfiguration()\n            throws InvalidKerasConfigurationException, UnsupportedKerasConfigurationException {\n        if (!this.className.equals(config.getFieldClassNameSequential()))\n            throw new InvalidKerasConfigurationException(\n                    \"Keras model class name \" + this.className + \" incompatible with MultiLayerNetwork\");\n        if (this.inputLayerNames.size() != 1)\n            throw new InvalidKerasConfigurationException(\n                    \"MultiLayerNetwork expects only 1 input (found \" + this.inputLayerNames.size() + \")\");\n        if (this.outputLayerNames.size() != 1)\n            throw new InvalidKerasConfigurationException(\n                    \"MultiLayerNetwork expects only 1 output (found \" + this.outputLayerNames.size() + \")\");\n\n        NeuralNetConfiguration.Builder modelBuilder = new NeuralNetConfiguration.Builder();\n\n        if (optimizer != null) {\n            modelBuilder.updater(optimizer);\n        }\n\n        NeuralNetConfiguration.ListBuilder listBuilder = modelBuilder.list();\n\n        /* Add layers one at a time. */\n        KerasLayer prevLayer = null;\n        int layerIndex = 0;\n        for (KerasLayer layer : this.layersOrdered) {\n            if (layer.isLayer()) {\n                int nbInbound = layer.getInboundLayerNames().size();\n                if (nbInbound != 1)\n                    throw new InvalidKerasConfigurationException(\n                            \"Layers in MultiLayerConfiguration must have exactly one inbound layer (found \"\n                                    + nbInbound + \" for layer \" + layer.getLayerName() + \")\");\n                if (prevLayer != null) {\n                    InputType[] inputTypes = new InputType[1];\n                    InputPreProcessor preprocessor;\n                    if (prevLayer.isInputPreProcessor()) {\n                        inputTypes[0] = this.outputTypes.get(prevLayer.getInboundLayerNames().get(0));\n                        preprocessor = prevLayer.getInputPreprocessor(inputTypes);\n                    } else {\n                        inputTypes[0] = this.outputTypes.get(prevLayer.getLayerName());\n                        preprocessor = layer.getInputPreprocessor(inputTypes);\n                    }\n                    if (preprocessor != null)\n                        listBuilder.inputPreProcessor(layerIndex, preprocessor);\n                }\n                listBuilder.layer(layerIndex++, layer.getLayer());\n            } else if (layer.getVertex() != null)\n                throw new InvalidKerasConfigurationException(\"Cannot add vertex to MultiLayerConfiguration (class name \"\n                        + layer.getClassName() + \", layer name \" + layer.getLayerName() + \")\");\n            prevLayer = layer;\n        }\n\n        InputType inputType = this.layersOrdered.get(0).getOutputType();\n        if (inputType != null)\n            listBuilder.setInputType(inputType);\n\n        /* Whether to use standard backprop (or BPTT) or truncated BPTT. */\n        if (this.useTruncatedBPTT && this.truncatedBPTT > 0)\n            listBuilder.backpropType(BackpropType.TruncatedBPTT).tBPTTForwardLength(truncatedBPTT)\n                    .tBPTTBackwardLength(truncatedBPTT);\n        else\n            listBuilder.backpropType(BackpropType.Standard);\n        return listBuilder.build();\n    }"}, {"code": "public void removesScanResult(String uri, String method) {\n\t\tSpiderScanResult toRemove = new SpiderScanResult(uri, method);\n\t\tint index = scanResults.indexOf(toRemove);\n\t\tif (index >= 0) {\n\t\t\tscanResults.remove(index);\n\t\t\tfireTableRowsDeleted(index, index);\n\t\t}\n\t}", "code_tokens": ["public", "void", "removesScanResult", "(", "String", "uri", ",", "String", "method", ")", "{", "SpiderScanResult", "toRemove", "=", "new", "SpiderScanResult", "(", "uri", ",", "method", ")", ";", "int", "index", "=", "scanResults", ".", "indexOf", "(", "toRemove", ")", ";", "if", "(", "index", ">=", "0", ")", "{", "scanResults", ".", "remove", "(", "index", ")", ";", "fireTableRowsDeleted", "(", "index", ",", "index", ")", ";", "}", "}"], "original_string": "public void removesScanResult(String uri, String method) {\n\t\tSpiderScanResult toRemove = new SpiderScanResult(uri, method);\n\t\tint index = scanResults.indexOf(toRemove);\n\t\tif (index >= 0) {\n\t\t\tscanResults.remove(index);\n\t\t\tfireTableRowsDeleted(index, index);\n\t\t}\n\t}"}, {"code": "private int readUnsignedVarInt() throws IOException {\n    int value = 0;\n    int shift = 0;\n    int b;\n    do {\n      b = in.read();\n      value |= (b & 0x7F) << shift;\n      shift += 7;\n    } while ((b & 0x80) != 0);\n    return value;\n  }", "code_tokens": ["private", "int", "readUnsignedVarInt", "(", ")", "throws", "IOException", "{", "int", "value", "=", "0", ";", "int", "shift", "=", "0", ";", "int", "b", ";", "do", "{", "b", "=", "in", ".", "read", "(", ")", ";", "value", "|=", "(", "b", "&", "0x7F", ")", "<<", "shift", ";", "shift", "+=", "7", ";", "}", "while", "(", "(", "b", "&", "0x80", ")", "!=", "0", ")", ";", "return", "value", ";", "}"], "original_string": "private int readUnsignedVarInt() throws IOException {\n    int value = 0;\n    int shift = 0;\n    int b;\n    do {\n      b = in.read();\n      value |= (b & 0x7F) << shift;\n      shift += 7;\n    } while ((b & 0x80) != 0);\n    return value;\n  }"}, {"code": "public static void binary(Image srcImage, ImageOutputStream destImageStream, String imageType) throws IORuntimeException {\r\n\t\twrite(binary(srcImage), imageType, destImageStream);\r\n\t}", "code_tokens": ["public", "static", "void", "binary", "(", "Image", "srcImage", ",", "ImageOutputStream", "destImageStream", ",", "String", "imageType", ")", "throws", "IORuntimeException", "{", "write", "(", "binary", "(", "srcImage", ")", ",", "imageType", ",", "destImageStream", ")", ";", "}"], "original_string": "public static void binary(Image srcImage, ImageOutputStream destImageStream, String imageType) throws IORuntimeException {\r\n\t\twrite(binary(srcImage), imageType, destImageStream);\r\n\t}"}, {"code": "public List<VocabularyWord> words() {\n        List<VocabularyWord> vocab = new ArrayList<>(vocabulary.values());\n        Collections.sort(vocab, new Comparator<VocabularyWord>() {\n            @Override\n            public int compare(VocabularyWord o1, VocabularyWord o2) {\n                return Integer.compare(o2.getCount(), o1.getCount());\n            }\n        });\n\n        return vocab;\n    }", "code_tokens": ["public", "List", "<", "VocabularyWord", ">", "words", "(", ")", "{", "List", "<", "VocabularyWord", ">", "vocab", "=", "new", "ArrayList", "<>", "(", "vocabulary", ".", "values", "(", ")", ")", ";", "Collections", ".", "sort", "(", "vocab", ",", "new", "Comparator", "<", "VocabularyWord", ">", "(", ")", "{", "@", "Override", "public", "int", "compare", "(", "VocabularyWord", "o1", ",", "VocabularyWord", "o2", ")", "{", "return", "Integer", ".", "compare", "(", "o2", ".", "getCount", "(", ")", ",", "o1", ".", "getCount", "(", ")", ")", ";", "}", "}", ")", ";", "return", "vocab", ";", "}"], "original_string": "public List<VocabularyWord> words() {\n        List<VocabularyWord> vocab = new ArrayList<>(vocabulary.values());\n        Collections.sort(vocab, new Comparator<VocabularyWord>() {\n            @Override\n            public int compare(VocabularyWord o1, VocabularyWord o2) {\n                return Integer.compare(o2.getCount(), o1.getCount());\n            }\n        });\n\n        return vocab;\n    }"}, {"code": "public <T> T find(Connection conn, Collection<String> fields, Entity where, RsHandler<T> rsh) throws SQLException {\r\n\t\tfinal Query query = new Query(SqlUtil.buildConditions(where), where.getTableName());\r\n\t\tquery.setFields(fields);\r\n\t\treturn find(conn, query, rsh);\r\n\t}", "code_tokens": ["public", "<", "T", ">", "T", "find", "(", "Connection", "conn", ",", "Collection", "<", "String", ">", "fields", ",", "Entity", "where", ",", "RsHandler", "<", "T", ">", "rsh", ")", "throws", "SQLException", "{", "final", "Query", "query", "=", "new", "Query", "(", "SqlUtil", ".", "buildConditions", "(", "where", ")", ",", "where", ".", "getTableName", "(", ")", ")", ";", "query", ".", "setFields", "(", "fields", ")", ";", "return", "find", "(", "conn", ",", "query", ",", "rsh", ")", ";", "}"], "original_string": "public <T> T find(Connection conn, Collection<String> fields, Entity where, RsHandler<T> rsh) throws SQLException {\r\n\t\tfinal Query query = new Query(SqlUtil.buildConditions(where), where.getTableName());\r\n\t\tquery.setFields(fields);\r\n\t\treturn find(conn, query, rsh);\r\n\t}"}, {"code": "public static SearchFilter newLdaptiveSearchFilter(final String filterQuery, final String paramName, final List<String> params) {\n        val filter = new SearchFilter();\n        filter.setFilter(filterQuery);\n        if (params != null) {\n            IntStream.range(0, params.size()).forEach(i -> {\n                if (filter.getFilter().contains(\"{\" + i + '}')) {\n                    filter.setParameter(i, params.get(i));\n                } else {\n                    filter.setParameter(paramName, params.get(i));\n                }\n            });\n        }\n        LOGGER.debug(\"Constructed LDAP search filter [{}]\", filter.format());\n        return filter;\n    }", "code_tokens": ["public", "static", "SearchFilter", "newLdaptiveSearchFilter", "(", "final", "String", "filterQuery", ",", "final", "String", "paramName", ",", "final", "List", "<", "String", ">", "params", ")", "{", "val", "filter", "=", "new", "SearchFilter", "(", ")", ";", "filter", ".", "setFilter", "(", "filterQuery", ")", ";", "if", "(", "params", "!=", "null", ")", "{", "IntStream", ".", "range", "(", "0", ",", "params", ".", "size", "(", ")", ")", ".", "forEach", "(", "i", "->", "{", "if", "(", "filter", ".", "getFilter", "(", ")", ".", "contains", "(", "\"{\"", "+", "i", "+", "'", "'", ")", ")", "{", "filter", ".", "setParameter", "(", "i", ",", "params", ".", "get", "(", "i", ")", ")", ";", "}", "else", "{", "filter", ".", "setParameter", "(", "paramName", ",", "params", ".", "get", "(", "i", ")", ")", ";", "}", "}", ")", ";", "}", "LOGGER", ".", "debug", "(", "\"Constructed LDAP search filter [{}]\"", ",", "filter", ".", "format", "(", ")", ")", ";", "return", "filter", ";", "}"], "original_string": "public static SearchFilter newLdaptiveSearchFilter(final String filterQuery, final String paramName, final List<String> params) {\n        val filter = new SearchFilter();\n        filter.setFilter(filterQuery);\n        if (params != null) {\n            IntStream.range(0, params.size()).forEach(i -> {\n                if (filter.getFilter().contains(\"{\" + i + '}')) {\n                    filter.setParameter(i, params.get(i));\n                } else {\n                    filter.setParameter(paramName, params.get(i));\n                }\n            });\n        }\n        LOGGER.debug(\"Constructed LDAP search filter [{}]\", filter.format());\n        return filter;\n    }"}, {"code": "public static <T, R> Supplier<R> andThen(Supplier<T> supplier, BiFunction<T, Exception, R> handler){\n        return () -> {\n            try{\n                T result = supplier.get();\n                return handler.apply(result, null);\n            }catch (Exception exception){\n                return handler.apply(null, exception);\n            }\n        };\n    }", "code_tokens": ["public", "static", "<", "T", ",", "R", ">", "Supplier", "<", "R", ">", "andThen", "(", "Supplier", "<", "T", ">", "supplier", ",", "BiFunction", "<", "T", ",", "Exception", ",", "R", ">", "handler", ")", "{", "return", "(", ")", "->", "{", "try", "{", "T", "result", "=", "supplier", ".", "get", "(", ")", ";", "return", "handler", ".", "apply", "(", "result", ",", "null", ")", ";", "}", "catch", "(", "Exception", "exception", ")", "{", "return", "handler", ".", "apply", "(", "null", ",", "exception", ")", ";", "}", "}", ";", "}"], "original_string": "public static <T, R> Supplier<R> andThen(Supplier<T> supplier, BiFunction<T, Exception, R> handler){\n        return () -> {\n            try{\n                T result = supplier.get();\n                return handler.apply(result, null);\n            }catch (Exception exception){\n                return handler.apply(null, exception);\n            }\n        };\n    }"}, {"code": "protected void addMetadataFiltersToMetadataResolver(final AbstractMetadataResolver metadataProvider, final MetadataFilter... metadataFilterList) {\n        addMetadataFiltersToMetadataResolver(metadataProvider, Arrays.stream(metadataFilterList).collect(Collectors.toList()));\n    }", "code_tokens": ["protected", "void", "addMetadataFiltersToMetadataResolver", "(", "final", "AbstractMetadataResolver", "metadataProvider", ",", "final", "MetadataFilter", "...", "metadataFilterList", ")", "{", "addMetadataFiltersToMetadataResolver", "(", "metadataProvider", ",", "Arrays", ".", "stream", "(", "metadataFilterList", ")", ".", "collect", "(", "Collectors", ".", "toList", "(", ")", ")", ")", ";", "}"], "original_string": "protected void addMetadataFiltersToMetadataResolver(final AbstractMetadataResolver metadataProvider, final MetadataFilter... metadataFilterList) {\n        addMetadataFiltersToMetadataResolver(metadataProvider, Arrays.stream(metadataFilterList).collect(Collectors.toList()));\n    }"}, {"code": "@Override\n  protected Object primTransform(Object anObject) throws Exception {\n    return Integer.valueOf(((Long) anObject).toString());\n  }", "code_tokens": ["@", "Override", "protected", "Object", "primTransform", "(", "Object", "anObject", ")", "throws", "Exception", "{", "return", "Integer", ".", "valueOf", "(", "(", "(", "Long", ")", "anObject", ")", ".", "toString", "(", ")", ")", ";", "}"], "original_string": "@Override\n  protected Object primTransform(Object anObject) throws Exception {\n    return Integer.valueOf(((Long) anObject).toString());\n  }"}, {"code": "@Nullable\n  public LookupExtractorFactoryMapContainer getLookup(final String tier, final String lookupName)\n  {\n    final Map<String, Map<String, LookupExtractorFactoryMapContainer>> prior = getKnownLookups();\n    if (prior == null) {\n      LOG.warn(\"Requested tier [%s] lookupName [%s]. But no lookups exist!\", tier, lookupName);\n      return null;\n    }\n    final Map<String, LookupExtractorFactoryMapContainer> tierLookups = prior.get(tier);\n    if (tierLookups == null) {\n      LOG.warn(\"Tier [%s] does not exist\", tier);\n      return null;\n    }\n    return tierLookups.get(lookupName);\n  }", "code_tokens": ["@", "Nullable", "public", "LookupExtractorFactoryMapContainer", "getLookup", "(", "final", "String", "tier", ",", "final", "String", "lookupName", ")", "{", "final", "Map", "<", "String", ",", "Map", "<", "String", ",", "LookupExtractorFactoryMapContainer", ">", ">", "prior", "=", "getKnownLookups", "(", ")", ";", "if", "(", "prior", "==", "null", ")", "{", "LOG", ".", "warn", "(", "\"Requested tier [%s] lookupName [%s]. But no lookups exist!\"", ",", "tier", ",", "lookupName", ")", ";", "return", "null", ";", "}", "final", "Map", "<", "String", ",", "LookupExtractorFactoryMapContainer", ">", "tierLookups", "=", "prior", ".", "get", "(", "tier", ")", ";", "if", "(", "tierLookups", "==", "null", ")", "{", "LOG", ".", "warn", "(", "\"Tier [%s] does not exist\"", ",", "tier", ")", ";", "return", "null", ";", "}", "return", "tierLookups", ".", "get", "(", "lookupName", ")", ";", "}"], "original_string": "@Nullable\n  public LookupExtractorFactoryMapContainer getLookup(final String tier, final String lookupName)\n  {\n    final Map<String, Map<String, LookupExtractorFactoryMapContainer>> prior = getKnownLookups();\n    if (prior == null) {\n      LOG.warn(\"Requested tier [%s] lookupName [%s]. But no lookups exist!\", tier, lookupName);\n      return null;\n    }\n    final Map<String, LookupExtractorFactoryMapContainer> tierLookups = prior.get(tier);\n    if (tierLookups == null) {\n      LOG.warn(\"Tier [%s] does not exist\", tier);\n      return null;\n    }\n    return tierLookups.get(lookupName);\n  }"}, {"code": "public byte[][] readImagesUnsafe(int nImages) throws IOException {\n        byte[][] out = new byte[nImages][0];\n        for (int i = 0; i < nImages; i++) {\n            out[i] = new byte[rows * cols];\n            read(out[i]);\n        }\n        return out;\n    }", "code_tokens": ["public", "byte", "[", "]", "[", "]", "readImagesUnsafe", "(", "int", "nImages", ")", "throws", "IOException", "{", "byte", "[", "]", "[", "]", "out", "=", "new", "byte", "[", "nImages", "]", "[", "0", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "nImages", ";", "i", "++", ")", "{", "out", "[", "i", "]", "=", "new", "byte", "[", "rows", "*", "cols", "]", ";", "read", "(", "out", "[", "i", "]", ")", ";", "}", "return", "out", ";", "}"], "original_string": "public byte[][] readImagesUnsafe(int nImages) throws IOException {\n        byte[][] out = new byte[nImages][0];\n        for (int i = 0; i < nImages; i++) {\n            out[i] = new byte[rows * cols];\n            read(out[i]);\n        }\n        return out;\n    }"}, {"code": "@SneakyThrows\n    public DocumentDbMappingContext createDocumentDbMappingContext() {\n        val documentDbMappingContext = new DocumentDbMappingContext();\n        documentDbMappingContext.setInitialEntitySet(new EntityScanner(applicationContext).scan(Persistent.class));\n        return documentDbMappingContext;\n    }", "code_tokens": ["@", "SneakyThrows", "public", "DocumentDbMappingContext", "createDocumentDbMappingContext", "(", ")", "{", "val", "documentDbMappingContext", "=", "new", "DocumentDbMappingContext", "(", ")", ";", "documentDbMappingContext", ".", "setInitialEntitySet", "(", "new", "EntityScanner", "(", "applicationContext", ")", ".", "scan", "(", "Persistent", ".", "class", ")", ")", ";", "return", "documentDbMappingContext", ";", "}"], "original_string": "@SneakyThrows\n    public DocumentDbMappingContext createDocumentDbMappingContext() {\n        val documentDbMappingContext = new DocumentDbMappingContext();\n        documentDbMappingContext.setInitialEntitySet(new EntityScanner(applicationContext).scan(Persistent.class));\n        return documentDbMappingContext;\n    }"}, {"code": "private TypeSerializer<Object> createSerializer(Object key, int pos) {\n\t\tif (key == null) {\n\t\t\tthrow new NullKeyFieldException(pos);\n\t\t}\n\t\ttry {\n\t\t\tTypeInformation<Object> info = TypeExtractor.getForObject(key);\n\t\t\treturn info.createSerializer(executionConfig);\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tthrow new RuntimeException(\"Could not create key serializer for type \" + key);\n\t\t}\n\t}", "code_tokens": ["private", "TypeSerializer", "<", "Object", ">", "createSerializer", "(", "Object", "key", ",", "int", "pos", ")", "{", "if", "(", "key", "==", "null", ")", "{", "throw", "new", "NullKeyFieldException", "(", "pos", ")", ";", "}", "try", "{", "TypeInformation", "<", "Object", ">", "info", "=", "TypeExtractor", ".", "getForObject", "(", "key", ")", ";", "return", "info", ".", "createSerializer", "(", "executionConfig", ")", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "throw", "new", "RuntimeException", "(", "\"Could not create key serializer for type \"", "+", "key", ")", ";", "}", "}"], "original_string": "private TypeSerializer<Object> createSerializer(Object key, int pos) {\n\t\tif (key == null) {\n\t\t\tthrow new NullKeyFieldException(pos);\n\t\t}\n\t\ttry {\n\t\t\tTypeInformation<Object> info = TypeExtractor.getForObject(key);\n\t\t\treturn info.createSerializer(executionConfig);\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tthrow new RuntimeException(\"Could not create key serializer for type \" + key);\n\t\t}\n\t}"}, {"code": "public static List<RepoBranch> getRepoBranch(AbstractBuild r) {\n        List<RepoBranch> list = new ArrayList<>();\n        return getRepoBranchFromScmObject(r.getProject().getScm(), r);\n    }", "code_tokens": ["public", "static", "List", "<", "RepoBranch", ">", "getRepoBranch", "(", "AbstractBuild", "r", ")", "{", "List", "<", "RepoBranch", ">", "list", "=", "new", "ArrayList", "<>", "(", ")", ";", "return", "getRepoBranchFromScmObject", "(", "r", ".", "getProject", "(", ")", ".", "getScm", "(", ")", ",", "r", ")", ";", "}"], "original_string": "public static List<RepoBranch> getRepoBranch(AbstractBuild r) {\n        List<RepoBranch> list = new ArrayList<>();\n        return getRepoBranchFromScmObject(r.getProject().getScm(), r);\n    }"}, {"code": "public static String toFloatUnit(long size) {\n\t\tif (size < BYTE_UNIT_KILO) {\n\t\t\treturn String.format(\"%5d\", size);\n\t\t}\n\n\t\tif (size < BYTE_UNIT_MEGA) {\n\t\t\treturn String.format(\"%5.1fk\", size / (1d * BYTE_UNIT_KILO));\n\t\t}\n\n\t\tif (size < BYTE_UNIT_GIGA) {\n\t\t\treturn String.format(\"%5.1fm\", size / (1d * BYTE_UNIT_MEGA));\n\t\t}\n\n\t\tif (size < BYTE_UNIT_TERA) {\n\t\t\treturn String.format(\"%5.1fg\", size / (1d * BYTE_UNIT_GIGA));\n\t\t}\n\n\t\treturn String.format(\"%5.1ft\", size / (1d * BYTE_UNIT_TERA));\n\t}", "code_tokens": ["public", "static", "String", "toFloatUnit", "(", "long", "size", ")", "{", "if", "(", "size", "<", "BYTE_UNIT_KILO", ")", "{", "return", "String", ".", "format", "(", "\"%5d\"", ",", "size", ")", ";", "}", "if", "(", "size", "<", "BYTE_UNIT_MEGA", ")", "{", "return", "String", ".", "format", "(", "\"%5.1fk\"", ",", "size", "/", "(", "1d", "*", "BYTE_UNIT_KILO", ")", ")", ";", "}", "if", "(", "size", "<", "BYTE_UNIT_GIGA", ")", "{", "return", "String", ".", "format", "(", "\"%5.1fm\"", ",", "size", "/", "(", "1d", "*", "BYTE_UNIT_MEGA", ")", ")", ";", "}", "if", "(", "size", "<", "BYTE_UNIT_TERA", ")", "{", "return", "String", ".", "format", "(", "\"%5.1fg\"", ",", "size", "/", "(", "1d", "*", "BYTE_UNIT_GIGA", ")", ")", ";", "}", "return", "String", ".", "format", "(", "\"%5.1ft\"", ",", "size", "/", "(", "1d", "*", "BYTE_UNIT_TERA", ")", ")", ";", "}"], "original_string": "public static String toFloatUnit(long size) {\n\t\tif (size < BYTE_UNIT_KILO) {\n\t\t\treturn String.format(\"%5d\", size);\n\t\t}\n\n\t\tif (size < BYTE_UNIT_MEGA) {\n\t\t\treturn String.format(\"%5.1fk\", size / (1d * BYTE_UNIT_KILO));\n\t\t}\n\n\t\tif (size < BYTE_UNIT_GIGA) {\n\t\t\treturn String.format(\"%5.1fm\", size / (1d * BYTE_UNIT_MEGA));\n\t\t}\n\n\t\tif (size < BYTE_UNIT_TERA) {\n\t\t\treturn String.format(\"%5.1fg\", size / (1d * BYTE_UNIT_GIGA));\n\t\t}\n\n\t\treturn String.format(\"%5.1ft\", size / (1d * BYTE_UNIT_TERA));\n\t}"}, {"code": "public double recall(int classLabel, double edgeCase) {\n        double tpCount = truePositives.getCount(classLabel);\n        double fnCount = falseNegatives.getCount(classLabel);\n\n        return EvaluationUtils.recall((long) tpCount, (long) fnCount, edgeCase);\n    }", "code_tokens": ["public", "double", "recall", "(", "int", "classLabel", ",", "double", "edgeCase", ")", "{", "double", "tpCount", "=", "truePositives", ".", "getCount", "(", "classLabel", ")", ";", "double", "fnCount", "=", "falseNegatives", ".", "getCount", "(", "classLabel", ")", ";", "return", "EvaluationUtils", ".", "recall", "(", "(", "long", ")", "tpCount", ",", "(", "long", ")", "fnCount", ",", "edgeCase", ")", ";", "}"], "original_string": "public double recall(int classLabel, double edgeCase) {\n        double tpCount = truePositives.getCount(classLabel);\n        double fnCount = falseNegatives.getCount(classLabel);\n\n        return EvaluationUtils.recall((long) tpCount, (long) fnCount, edgeCase);\n    }"}, {"code": "void updateInstance(T instance) {\n        T oldInstance = this.instance.getAndSet(Preconditions.checkNotNull(instance, \"instance\"));\n        if (oldInstance != null && oldInstance != instance) {\n            oldInstance.close();\n        }\n    }", "code_tokens": ["void", "updateInstance", "(", "T", "instance", ")", "{", "T", "oldInstance", "=", "this", ".", "instance", ".", "getAndSet", "(", "Preconditions", ".", "checkNotNull", "(", "instance", ",", "\"instance\"", ")", ")", ";", "if", "(", "oldInstance", "!=", "null", "&&", "oldInstance", "!=", "instance", ")", "{", "oldInstance", ".", "close", "(", ")", ";", "}", "}"], "original_string": "void updateInstance(T instance) {\n        T oldInstance = this.instance.getAndSet(Preconditions.checkNotNull(instance, \"instance\"));\n        if (oldInstance != null && oldInstance != instance) {\n            oldInstance.close();\n        }\n    }"}, {"code": "Driver provideHiveDriver() {\n    HiveConf hiveConf = provideHiveConf();\n    SessionState.start(hiveConf);\n\n    return new Driver(hiveConf);\n  }", "code_tokens": ["Driver", "provideHiveDriver", "(", ")", "{", "HiveConf", "hiveConf", "=", "provideHiveConf", "(", ")", ";", "SessionState", ".", "start", "(", "hiveConf", ")", ";", "return", "new", "Driver", "(", "hiveConf", ")", ";", "}"], "original_string": "Driver provideHiveDriver() {\n    HiveConf hiveConf = provideHiveConf();\n    SessionState.start(hiveConf);\n\n    return new Driver(hiveConf);\n  }"}, {"code": "public static Method getPublicMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) throws SecurityException {\r\n\t\treturn ReflectUtil.getPublicMethod(clazz, methodName, paramTypes);\r\n\t}", "code_tokens": ["public", "static", "Method", "getPublicMethod", "(", "Class", "<", "?", ">", "clazz", ",", "String", "methodName", ",", "Class", "<", "?", ">", "...", "paramTypes", ")", "throws", "SecurityException", "{", "return", "ReflectUtil", ".", "getPublicMethod", "(", "clazz", ",", "methodName", ",", "paramTypes", ")", ";", "}"], "original_string": "public static Method getPublicMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) throws SecurityException {\r\n\t\treturn ReflectUtil.getPublicMethod(clazz, methodName, paramTypes);\r\n\t}"}, {"code": "public static ClassResolver weakCachingResolver(ClassLoader classLoader) {\n        return new CachingClassResolver(\n                new ClassLoaderClassResolver(defaultClassLoader(classLoader)),\n                new WeakReferenceMap<String, Class<?>>(new HashMap<String, Reference<Class<?>>>()));\n    }", "code_tokens": ["public", "static", "ClassResolver", "weakCachingResolver", "(", "ClassLoader", "classLoader", ")", "{", "return", "new", "CachingClassResolver", "(", "new", "ClassLoaderClassResolver", "(", "defaultClassLoader", "(", "classLoader", ")", ")", ",", "new", "WeakReferenceMap", "<", "String", ",", "Class", "<", "?", ">", ">", "(", "new", "HashMap", "<", "String", ",", "Reference", "<", "Class", "<", "?", ">", ">", ">", "(", ")", ")", ")", ";", "}"], "original_string": "public static ClassResolver weakCachingResolver(ClassLoader classLoader) {\n        return new CachingClassResolver(\n                new ClassLoaderClassResolver(defaultClassLoader(classLoader)),\n                new WeakReferenceMap<String, Class<?>>(new HashMap<String, Reference<Class<?>>>()));\n    }"}, {"code": "public static double getStirlingError(double z) {\n        double ret;\n        if (z < 15.0) {\n            double z2 = 2.0 * z;\n            if (FastMath.floor(z2) == z2) {\n                ret = EXACT_STIRLING_ERRORS[(int) z2];\n            } else {\n                ret = Gamma.logGamma(z + 1.0) - (z + 0.5) * FastMath.log(z) + z - HALF_LOG_2_PI;\n            }\n        } else {\n            double z2 = z * z;\n            ret = (0.083333333333333333333 - (0.00277777777777777777778 - (0.00079365079365079365079365\n                            - (0.000595238095238095238095238 - 0.0008417508417508417508417508 / z2) / z2) / z2) / z2)\n                            / z;\n        }\n        return ret;\n    }", "code_tokens": ["public", "static", "double", "getStirlingError", "(", "double", "z", ")", "{", "double", "ret", ";", "if", "(", "z", "<", "15.0", ")", "{", "double", "z2", "=", "2.0", "*", "z", ";", "if", "(", "FastMath", ".", "floor", "(", "z2", ")", "==", "z2", ")", "{", "ret", "=", "EXACT_STIRLING_ERRORS", "[", "(", "int", ")", "z2", "]", ";", "}", "else", "{", "ret", "=", "Gamma", ".", "logGamma", "(", "z", "+", "1.0", ")", "-", "(", "z", "+", "0.5", ")", "*", "FastMath", ".", "log", "(", "z", ")", "+", "z", "-", "HALF_LOG_2_PI", ";", "}", "}", "else", "{", "double", "z2", "=", "z", "*", "z", ";", "ret", "=", "(", "0.083333333333333333333", "-", "(", "0.00277777777777777777778", "-", "(", "0.00079365079365079365079365", "-", "(", "0.000595238095238095238095238", "-", "0.0008417508417508417508417508", "/", "z2", ")", "/", "z2", ")", "/", "z2", ")", "/", "z2", ")", "/", "z", ";", "}", "return", "ret", ";", "}"], "original_string": "public static double getStirlingError(double z) {\n        double ret;\n        if (z < 15.0) {\n            double z2 = 2.0 * z;\n            if (FastMath.floor(z2) == z2) {\n                ret = EXACT_STIRLING_ERRORS[(int) z2];\n            } else {\n                ret = Gamma.logGamma(z + 1.0) - (z + 0.5) * FastMath.log(z) + z - HALF_LOG_2_PI;\n            }\n        } else {\n            double z2 = z * z;\n            ret = (0.083333333333333333333 - (0.00277777777777777777778 - (0.00079365079365079365079365\n                            - (0.000595238095238095238095238 - 0.0008417508417508417508417508 / z2) / z2) / z2) / z2)\n                            / z;\n        }\n        return ret;\n    }"}, {"code": "@SuppressWarnings(\"rawtypes\")\r\n\tpublic static HashMap<Object, Object> of(Object[] array) {\r\n\t\tif (array == null) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tfinal HashMap<Object, Object> map = new HashMap<>((int) (array.length * 1.5));\r\n\t\tfor (int i = 0; i < array.length; i++) {\r\n\t\t\tObject object = array[i];\r\n\t\t\tif (object instanceof Map.Entry) {\r\n\t\t\t\tMap.Entry entry = (Map.Entry) object;\r\n\t\t\t\tmap.put(entry.getKey(), entry.getValue());\r\n\t\t\t} else if (object instanceof Object[]) {\r\n\t\t\t\tfinal Object[] entry = (Object[]) object;\r\n\t\t\t\tif (entry.length > 1) {\r\n\t\t\t\t\tmap.put(entry[0], entry[1]);\r\n\t\t\t\t}\r\n\t\t\t} else if (object instanceof Iterable) {\r\n\t\t\t\tIterator iter = ((Iterable) object).iterator();\r\n\t\t\t\tif (iter.hasNext()) {\r\n\t\t\t\t\tfinal Object key = iter.next();\r\n\t\t\t\t\tif (iter.hasNext()) {\r\n\t\t\t\t\t\tfinal Object value = iter.next();\r\n\t\t\t\t\t\tmap.put(key, value);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (object instanceof Iterator) {\r\n\t\t\t\tIterator iter = ((Iterator) object);\r\n\t\t\t\tif (iter.hasNext()) {\r\n\t\t\t\t\tfinal Object key = iter.next();\r\n\t\t\t\t\tif (iter.hasNext()) {\r\n\t\t\t\t\t\tfinal Object value = iter.next();\r\n\t\t\t\t\t\tmap.put(key, value);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthrow new IllegalArgumentException(StrUtil.format(\"Array element {}, '{}', is not type of Map.Entry or Array or Iterable or Iterator\", i, object));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn map;\r\n\t}", "code_tokens": ["@", "SuppressWarnings", "(", "\"rawtypes\"", ")", "public", "static", "HashMap", "<", "Object", ",", "Object", ">", "of", "(", "Object", "[", "]", "array", ")", "{", "if", "(", "array", "==", "null", ")", "{", "return", "null", ";", "}", "final", "HashMap", "<", "Object", ",", "Object", ">", "map", "=", "new", "HashMap", "<>", "(", "(", "int", ")", "(", "array", ".", "length", "*", "1.5", ")", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "array", ".", "length", ";", "i", "++", ")", "{", "Object", "object", "=", "array", "[", "i", "]", ";", "if", "(", "object", "instanceof", "Map", ".", "Entry", ")", "{", "Map", ".", "Entry", "entry", "=", "(", "Map", ".", "Entry", ")", "object", ";", "map", ".", "put", "(", "entry", ".", "getKey", "(", ")", ",", "entry", ".", "getValue", "(", ")", ")", ";", "}", "else", "if", "(", "object", "instanceof", "Object", "[", "]", ")", "{", "final", "Object", "[", "]", "entry", "=", "(", "Object", "[", "]", ")", "object", ";", "if", "(", "entry", ".", "length", ">", "1", ")", "{", "map", ".", "put", "(", "entry", "[", "0", "]", ",", "entry", "[", "1", "]", ")", ";", "}", "}", "else", "if", "(", "object", "instanceof", "Iterable", ")", "{", "Iterator", "iter", "=", "(", "(", "Iterable", ")", "object", ")", ".", "iterator", "(", ")", ";", "if", "(", "iter", ".", "hasNext", "(", ")", ")", "{", "final", "Object", "key", "=", "iter", ".", "next", "(", ")", ";", "if", "(", "iter", ".", "hasNext", "(", ")", ")", "{", "final", "Object", "value", "=", "iter", ".", "next", "(", ")", ";", "map", ".", "put", "(", "key", ",", "value", ")", ";", "}", "}", "}", "else", "if", "(", "object", "instanceof", "Iterator", ")", "{", "Iterator", "iter", "=", "(", "(", "Iterator", ")", "object", ")", ";", "if", "(", "iter", ".", "hasNext", "(", ")", ")", "{", "final", "Object", "key", "=", "iter", ".", "next", "(", ")", ";", "if", "(", "iter", ".", "hasNext", "(", ")", ")", "{", "final", "Object", "value", "=", "iter", ".", "next", "(", ")", ";", "map", ".", "put", "(", "key", ",", "value", ")", ";", "}", "}", "}", "else", "{", "throw", "new", "IllegalArgumentException", "(", "StrUtil", ".", "format", "(", "\"Array element {}, '{}', is not type of Map.Entry or Array or Iterable or Iterator\"", ",", "i", ",", "object", ")", ")", ";", "}", "}", "return", "map", ";", "}"], "original_string": "@SuppressWarnings(\"rawtypes\")\r\n\tpublic static HashMap<Object, Object> of(Object[] array) {\r\n\t\tif (array == null) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tfinal HashMap<Object, Object> map = new HashMap<>((int) (array.length * 1.5));\r\n\t\tfor (int i = 0; i < array.length; i++) {\r\n\t\t\tObject object = array[i];\r\n\t\t\tif (object instanceof Map.Entry) {\r\n\t\t\t\tMap.Entry entry = (Map.Entry) object;\r\n\t\t\t\tmap.put(entry.getKey(), entry.getValue());\r\n\t\t\t} else if (object instanceof Object[]) {\r\n\t\t\t\tfinal Object[] entry = (Object[]) object;\r\n\t\t\t\tif (entry.length > 1) {\r\n\t\t\t\t\tmap.put(entry[0], entry[1]);\r\n\t\t\t\t}\r\n\t\t\t} else if (object instanceof Iterable) {\r\n\t\t\t\tIterator iter = ((Iterable) object).iterator();\r\n\t\t\t\tif (iter.hasNext()) {\r\n\t\t\t\t\tfinal Object key = iter.next();\r\n\t\t\t\t\tif (iter.hasNext()) {\r\n\t\t\t\t\t\tfinal Object value = iter.next();\r\n\t\t\t\t\t\tmap.put(key, value);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (object instanceof Iterator) {\r\n\t\t\t\tIterator iter = ((Iterator) object);\r\n\t\t\t\tif (iter.hasNext()) {\r\n\t\t\t\t\tfinal Object key = iter.next();\r\n\t\t\t\t\tif (iter.hasNext()) {\r\n\t\t\t\t\t\tfinal Object value = iter.next();\r\n\t\t\t\t\t\tmap.put(key, value);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthrow new IllegalArgumentException(StrUtil.format(\"Array element {}, '{}', is not type of Map.Entry or Array or Iterable or Iterator\", i, object));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn map;\r\n\t}"}, {"code": "public static String getProcessRoot(Long pipelineId) {\n        // \u6839\u636echannelId , pipelineId\u6784\u9020path\n        return MessageFormat.format(ArbitrateConstants.NODE_PROCESS_ROOT, getChannelId(pipelineId),\n                                    String.valueOf(pipelineId));\n    }", "code_tokens": ["public", "static", "String", "getProcessRoot", "(", "Long", "pipelineId", ")", "{", "// \u6839\u636echannelId , pipelineId\u6784\u9020path", "return", "MessageFormat", ".", "format", "(", "ArbitrateConstants", ".", "NODE_PROCESS_ROOT", ",", "getChannelId", "(", "pipelineId", ")", ",", "String", ".", "valueOf", "(", "pipelineId", ")", ")", ";", "}"], "original_string": "public static String getProcessRoot(Long pipelineId) {\n        // \u6839\u636echannelId , pipelineId\u6784\u9020path\n        return MessageFormat.format(ArbitrateConstants.NODE_PROCESS_ROOT, getChannelId(pipelineId),\n                                    String.valueOf(pipelineId));\n    }"}, {"code": "public void reconnect(final JobID jobId) {\n\t\tPreconditions.checkNotNull(jobId, \"JobID must not be null.\");\n\n\t\tfinal Tuple2<LeaderRetrievalService, JobManagerLeaderListener> jobLeaderService = jobLeaderServices.get(jobId);\n\n\t\tif (jobLeaderService != null) {\n\t\t\tjobLeaderService.f1.reconnect();\n\t\t} else {\n\t\t\tLOG.info(\"Cannot reconnect to job {} because it is not registered.\", jobId);\n\t\t}\n\t}", "code_tokens": ["public", "void", "reconnect", "(", "final", "JobID", "jobId", ")", "{", "Preconditions", ".", "checkNotNull", "(", "jobId", ",", "\"JobID must not be null.\"", ")", ";", "final", "Tuple2", "<", "LeaderRetrievalService", ",", "JobManagerLeaderListener", ">", "jobLeaderService", "=", "jobLeaderServices", ".", "get", "(", "jobId", ")", ";", "if", "(", "jobLeaderService", "!=", "null", ")", "{", "jobLeaderService", ".", "f1", ".", "reconnect", "(", ")", ";", "}", "else", "{", "LOG", ".", "info", "(", "\"Cannot reconnect to job {} because it is not registered.\"", ",", "jobId", ")", ";", "}", "}"], "original_string": "public void reconnect(final JobID jobId) {\n\t\tPreconditions.checkNotNull(jobId, \"JobID must not be null.\");\n\n\t\tfinal Tuple2<LeaderRetrievalService, JobManagerLeaderListener> jobLeaderService = jobLeaderServices.get(jobId);\n\n\t\tif (jobLeaderService != null) {\n\t\t\tjobLeaderService.f1.reconnect();\n\t\t} else {\n\t\t\tLOG.info(\"Cannot reconnect to job {} because it is not registered.\", jobId);\n\t\t}\n\t}"}, {"code": "public static ClassLoader getClassLoader(Class<?> clazz) {\n        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n        if (loader != null) {\n            return loader;\n        }\n        if (clazz != null) {\n            loader = clazz.getClassLoader();\n            if (loader != null) {\n                return loader;\n            }\n        }\n        return ClassLoader.getSystemClassLoader();\n    }", "code_tokens": ["public", "static", "ClassLoader", "getClassLoader", "(", "Class", "<", "?", ">", "clazz", ")", "{", "ClassLoader", "loader", "=", "Thread", ".", "currentThread", "(", ")", ".", "getContextClassLoader", "(", ")", ";", "if", "(", "loader", "!=", "null", ")", "{", "return", "loader", ";", "}", "if", "(", "clazz", "!=", "null", ")", "{", "loader", "=", "clazz", ".", "getClassLoader", "(", ")", ";", "if", "(", "loader", "!=", "null", ")", "{", "return", "loader", ";", "}", "}", "return", "ClassLoader", ".", "getSystemClassLoader", "(", ")", ";", "}"], "original_string": "public static ClassLoader getClassLoader(Class<?> clazz) {\n        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n        if (loader != null) {\n            return loader;\n        }\n        if (clazz != null) {\n            loader = clazz.getClassLoader();\n            if (loader != null) {\n                return loader;\n            }\n        }\n        return ClassLoader.getSystemClassLoader();\n    }"}, {"code": "private void addNewBuilds(List<BambooJob> enabledJobs,\n                              Map<BambooJob, Set<Build>> buildsByJob) {\n        long start = System.currentTimeMillis();\n        int count = 0;\n\n        for (BambooJob job : enabledJobs) {\n            if (job.isPushed()) {\n                LOG.info(\"Job Pushed already: \" + job.getJobName());\n                continue;\n            }\n            // process new builds in the order of their build numbers - this has implication to handling of commits in BuildEventListener\n            ArrayList<Build> builds = Lists.newArrayList(nullSafe(buildsByJob.get(job)));\n            builds.sort((Build b1, Build b2) -> Integer.valueOf(b1.getNumber()) - Integer.valueOf(b2.getNumber()));\n            for (Build buildSummary : builds) {\n                if (isNewBuild(job, buildSummary)) {\n                    Build build = bambooClient.getBuildDetails(buildSummary\n                            .getBuildUrl(), job.getInstanceUrl());\n                    if (build != null) {\n                        build.setCollectorItemId(job.getId());\n                        buildRepository.save(build);\n                        count++;\n                    }\n                }\n            }\n        }\n        log(\"New builds\", start, count);\n    }", "code_tokens": ["private", "void", "addNewBuilds", "(", "List", "<", "BambooJob", ">", "enabledJobs", ",", "Map", "<", "BambooJob", ",", "Set", "<", "Build", ">", ">", "buildsByJob", ")", "{", "long", "start", "=", "System", ".", "currentTimeMillis", "(", ")", ";", "int", "count", "=", "0", ";", "for", "(", "BambooJob", "job", ":", "enabledJobs", ")", "{", "if", "(", "job", ".", "isPushed", "(", ")", ")", "{", "LOG", ".", "info", "(", "\"Job Pushed already: \"", "+", "job", ".", "getJobName", "(", ")", ")", ";", "continue", ";", "}", "// process new builds in the order of their build numbers - this has implication to handling of commits in BuildEventListener", "ArrayList", "<", "Build", ">", "builds", "=", "Lists", ".", "newArrayList", "(", "nullSafe", "(", "buildsByJob", ".", "get", "(", "job", ")", ")", ")", ";", "builds", ".", "sort", "(", "(", "Build", "b1", ",", "Build", "b2", ")", "->", "Integer", ".", "valueOf", "(", "b1", ".", "getNumber", "(", ")", ")", "-", "Integer", ".", "valueOf", "(", "b2", ".", "getNumber", "(", ")", ")", ")", ";", "for", "(", "Build", "buildSummary", ":", "builds", ")", "{", "if", "(", "isNewBuild", "(", "job", ",", "buildSummary", ")", ")", "{", "Build", "build", "=", "bambooClient", ".", "getBuildDetails", "(", "buildSummary", ".", "getBuildUrl", "(", ")", ",", "job", ".", "getInstanceUrl", "(", ")", ")", ";", "if", "(", "build", "!=", "null", ")", "{", "build", ".", "setCollectorItemId", "(", "job", ".", "getId", "(", ")", ")", ";", "buildRepository", ".", "save", "(", "build", ")", ";", "count", "++", ";", "}", "}", "}", "}", "log", "(", "\"New builds\"", ",", "start", ",", "count", ")", ";", "}"], "original_string": "private void addNewBuilds(List<BambooJob> enabledJobs,\n                              Map<BambooJob, Set<Build>> buildsByJob) {\n        long start = System.currentTimeMillis();\n        int count = 0;\n\n        for (BambooJob job : enabledJobs) {\n            if (job.isPushed()) {\n                LOG.info(\"Job Pushed already: \" + job.getJobName());\n                continue;\n            }\n            // process new builds in the order of their build numbers - this has implication to handling of commits in BuildEventListener\n            ArrayList<Build> builds = Lists.newArrayList(nullSafe(buildsByJob.get(job)));\n            builds.sort((Build b1, Build b2) -> Integer.valueOf(b1.getNumber()) - Integer.valueOf(b2.getNumber()));\n            for (Build buildSummary : builds) {\n                if (isNewBuild(job, buildSummary)) {\n                    Build build = bambooClient.getBuildDetails(buildSummary\n                            .getBuildUrl(), job.getInstanceUrl());\n                    if (build != null) {\n                        build.setCollectorItemId(job.getId());\n                        buildRepository.save(build);\n                        count++;\n                    }\n                }\n            }\n        }\n        log(\"New builds\", start, count);\n    }"}, {"code": "public com.google.cloud.datalabeling.v1beta1.BoundingPolyOrBuilder getBoundingPolyOrBuilder() {\n    if (boundedAreaCase_ == 2) {\n      return (com.google.cloud.datalabeling.v1beta1.BoundingPoly) boundedArea_;\n    }\n    return com.google.cloud.datalabeling.v1beta1.BoundingPoly.getDefaultInstance();\n  }", "code_tokens": ["public", "com", ".", "google", ".", "cloud", ".", "datalabeling", ".", "v1beta1", ".", "BoundingPolyOrBuilder", "getBoundingPolyOrBuilder", "(", ")", "{", "if", "(", "boundedAreaCase_", "==", "2", ")", "{", "return", "(", "com", ".", "google", ".", "cloud", ".", "datalabeling", ".", "v1beta1", ".", "BoundingPoly", ")", "boundedArea_", ";", "}", "return", "com", ".", "google", ".", "cloud", ".", "datalabeling", ".", "v1beta1", ".", "BoundingPoly", ".", "getDefaultInstance", "(", ")", ";", "}"], "original_string": "public com.google.cloud.datalabeling.v1beta1.BoundingPolyOrBuilder getBoundingPolyOrBuilder() {\n    if (boundedAreaCase_ == 2) {\n      return (com.google.cloud.datalabeling.v1beta1.BoundingPoly) boundedArea_;\n    }\n    return com.google.cloud.datalabeling.v1beta1.BoundingPoly.getDefaultInstance();\n  }"}, {"code": "private Pair<Gradient, INDArray> getGradientsAndDelta(INDArray preOut, LayerWorkspaceMgr workspaceMgr) {\n        ILossFunction lossFunction = layerConf().getLossFn();\n        INDArray labels2d = getLabels2d(workspaceMgr, ArrayType.BP_WORKING_MEM);\n        if (labels2d.size(1) != preOut.size(1)) {\n            throw new DL4JInvalidInputException(\n                            \"Labels array numColumns (size(1) = \" + labels2d.size(1) + \") does not match output layer\"\n                                            + \" number of outputs (nOut = \" + preOut.size(1) + \") \" + layerId());\n        }\n\n        INDArray delta = lossFunction.computeGradient(labels2d, preOut, layerConf().getActivationFn(), maskArray);\n\n        Gradient gradient = new DefaultGradient();\n\n        INDArray weightGradView = gradientViews.get(CenterLossParamInitializer.WEIGHT_KEY);\n        INDArray biasGradView = gradientViews.get(CenterLossParamInitializer.BIAS_KEY);\n        INDArray centersGradView = gradientViews.get(CenterLossParamInitializer.CENTER_KEY);\n\n        // centers delta\n        double alpha = layerConf().getAlpha();\n\n        INDArray centers = params.get(CenterLossParamInitializer.CENTER_KEY);\n        INDArray l = labels.castTo(centers.dataType()); //Ensure correct dtype (same as params); no-op if already correct dtype\n        INDArray centersForExamples = l.mmul(centers);\n        INDArray diff = centersForExamples.sub(input).muli(alpha);\n        INDArray numerator = l.transpose().mmul(diff);\n        INDArray denominator = l.sum(0).reshape(l.size(1), 1).addi(1.0);\n\n        INDArray deltaC;\n        if (layerConf().getGradientCheck()) {\n            double lambda = layerConf().getLambda();\n            //For gradient checks: need to multiply dLc/dcj by lambda to get dL/dcj\n            deltaC = numerator.muli(lambda);\n        } else {\n            deltaC = numerator.diviColumnVector(denominator);\n        }\n        centersGradView.assign(deltaC);\n\n\n\n        // other standard calculations\n        Nd4j.gemm(input, delta, weightGradView, true, false, 1.0, 0.0); //Equivalent to:  weightGradView.assign(input.transpose().mmul(delta));\n        delta.sum(biasGradView, 0); //biasGradView is initialized/zeroed first in sum op\n\n        gradient.gradientForVariable().put(CenterLossParamInitializer.WEIGHT_KEY, weightGradView);\n        gradient.gradientForVariable().put(CenterLossParamInitializer.BIAS_KEY, biasGradView);\n        gradient.gradientForVariable().put(CenterLossParamInitializer.CENTER_KEY, centersGradView);\n\n        return new Pair<>(gradient, delta);\n    }", "code_tokens": ["private", "Pair", "<", "Gradient", ",", "INDArray", ">", "getGradientsAndDelta", "(", "INDArray", "preOut", ",", "LayerWorkspaceMgr", "workspaceMgr", ")", "{", "ILossFunction", "lossFunction", "=", "layerConf", "(", ")", ".", "getLossFn", "(", ")", ";", "INDArray", "labels2d", "=", "getLabels2d", "(", "workspaceMgr", ",", "ArrayType", ".", "BP_WORKING_MEM", ")", ";", "if", "(", "labels2d", ".", "size", "(", "1", ")", "!=", "preOut", ".", "size", "(", "1", ")", ")", "{", "throw", "new", "DL4JInvalidInputException", "(", "\"Labels array numColumns (size(1) = \"", "+", "labels2d", ".", "size", "(", "1", ")", "+", "\") does not match output layer\"", "+", "\" number of outputs (nOut = \"", "+", "preOut", ".", "size", "(", "1", ")", "+", "\") \"", "+", "layerId", "(", ")", ")", ";", "}", "INDArray", "delta", "=", "lossFunction", ".", "computeGradient", "(", "labels2d", ",", "preOut", ",", "layerConf", "(", ")", ".", "getActivationFn", "(", ")", ",", "maskArray", ")", ";", "Gradient", "gradient", "=", "new", "DefaultGradient", "(", ")", ";", "INDArray", "weightGradView", "=", "gradientViews", ".", "get", "(", "CenterLossParamInitializer", ".", "WEIGHT_KEY", ")", ";", "INDArray", "biasGradView", "=", "gradientViews", ".", "get", "(", "CenterLossParamInitializer", ".", "BIAS_KEY", ")", ";", "INDArray", "centersGradView", "=", "gradientViews", ".", "get", "(", "CenterLossParamInitializer", ".", "CENTER_KEY", ")", ";", "// centers delta", "double", "alpha", "=", "layerConf", "(", ")", ".", "getAlpha", "(", ")", ";", "INDArray", "centers", "=", "params", ".", "get", "(", "CenterLossParamInitializer", ".", "CENTER_KEY", ")", ";", "INDArray", "l", "=", "labels", ".", "castTo", "(", "centers", ".", "dataType", "(", ")", ")", ";", "//Ensure correct dtype (same as params); no-op if already correct dtype", "INDArray", "centersForExamples", "=", "l", ".", "mmul", "(", "centers", ")", ";", "INDArray", "diff", "=", "centersForExamples", ".", "sub", "(", "input", ")", ".", "muli", "(", "alpha", ")", ";", "INDArray", "numerator", "=", "l", ".", "transpose", "(", ")", ".", "mmul", "(", "diff", ")", ";", "INDArray", "denominator", "=", "l", ".", "sum", "(", "0", ")", ".", "reshape", "(", "l", ".", "size", "(", "1", ")", ",", "1", ")", ".", "addi", "(", "1.0", ")", ";", "INDArray", "deltaC", ";", "if", "(", "layerConf", "(", ")", ".", "getGradientCheck", "(", ")", ")", "{", "double", "lambda", "=", "layerConf", "(", ")", ".", "getLambda", "(", ")", ";", "//For gradient checks: need to multiply dLc/dcj by lambda to get dL/dcj", "deltaC", "=", "numerator", ".", "muli", "(", "lambda", ")", ";", "}", "else", "{", "deltaC", "=", "numerator", ".", "diviColumnVector", "(", "denominator", ")", ";", "}", "centersGradView", ".", "assign", "(", "deltaC", ")", ";", "// other standard calculations", "Nd4j", ".", "gemm", "(", "input", ",", "delta", ",", "weightGradView", ",", "true", ",", "false", ",", "1.0", ",", "0.0", ")", ";", "//Equivalent to:  weightGradView.assign(input.transpose().mmul(delta));", "delta", ".", "sum", "(", "biasGradView", ",", "0", ")", ";", "//biasGradView is initialized/zeroed first in sum op", "gradient", ".", "gradientForVariable", "(", ")", ".", "put", "(", "CenterLossParamInitializer", ".", "WEIGHT_KEY", ",", "weightGradView", ")", ";", "gradient", ".", "gradientForVariable", "(", ")", ".", "put", "(", "CenterLossParamInitializer", ".", "BIAS_KEY", ",", "biasGradView", ")", ";", "gradient", ".", "gradientForVariable", "(", ")", ".", "put", "(", "CenterLossParamInitializer", ".", "CENTER_KEY", ",", "centersGradView", ")", ";", "return", "new", "Pair", "<>", "(", "gradient", ",", "delta", ")", ";", "}"], "original_string": "private Pair<Gradient, INDArray> getGradientsAndDelta(INDArray preOut, LayerWorkspaceMgr workspaceMgr) {\n        ILossFunction lossFunction = layerConf().getLossFn();\n        INDArray labels2d = getLabels2d(workspaceMgr, ArrayType.BP_WORKING_MEM);\n        if (labels2d.size(1) != preOut.size(1)) {\n            throw new DL4JInvalidInputException(\n                            \"Labels array numColumns (size(1) = \" + labels2d.size(1) + \") does not match output layer\"\n                                            + \" number of outputs (nOut = \" + preOut.size(1) + \") \" + layerId());\n        }\n\n        INDArray delta = lossFunction.computeGradient(labels2d, preOut, layerConf().getActivationFn(), maskArray);\n\n        Gradient gradient = new DefaultGradient();\n\n        INDArray weightGradView = gradientViews.get(CenterLossParamInitializer.WEIGHT_KEY);\n        INDArray biasGradView = gradientViews.get(CenterLossParamInitializer.BIAS_KEY);\n        INDArray centersGradView = gradientViews.get(CenterLossParamInitializer.CENTER_KEY);\n\n        // centers delta\n        double alpha = layerConf().getAlpha();\n\n        INDArray centers = params.get(CenterLossParamInitializer.CENTER_KEY);\n        INDArray l = labels.castTo(centers.dataType()); //Ensure correct dtype (same as params); no-op if already correct dtype\n        INDArray centersForExamples = l.mmul(centers);\n        INDArray diff = centersForExamples.sub(input).muli(alpha);\n        INDArray numerator = l.transpose().mmul(diff);\n        INDArray denominator = l.sum(0).reshape(l.size(1), 1).addi(1.0);\n\n        INDArray deltaC;\n        if (layerConf().getGradientCheck()) {\n            double lambda = layerConf().getLambda();\n            //For gradient checks: need to multiply dLc/dcj by lambda to get dL/dcj\n            deltaC = numerator.muli(lambda);\n        } else {\n            deltaC = numerator.diviColumnVector(denominator);\n        }\n        centersGradView.assign(deltaC);\n\n\n\n        // other standard calculations\n        Nd4j.gemm(input, delta, weightGradView, true, false, 1.0, 0.0); //Equivalent to:  weightGradView.assign(input.transpose().mmul(delta));\n        delta.sum(biasGradView, 0); //biasGradView is initialized/zeroed first in sum op\n\n        gradient.gradientForVariable().put(CenterLossParamInitializer.WEIGHT_KEY, weightGradView);\n        gradient.gradientForVariable().put(CenterLossParamInitializer.BIAS_KEY, biasGradView);\n        gradient.gradientForVariable().put(CenterLossParamInitializer.CENTER_KEY, centersGradView);\n\n        return new Pair<>(gradient, delta);\n    }"}, {"code": "public static MaxEntModel create(String path)\n    {\n        MaxEntModel m = new MaxEntModel();\n        try\n        {\n            BufferedReader br = new BufferedReader(new InputStreamReader(IOUtil.newInputStream(path), \"UTF-8\"));\n            DataOutputStream out = new DataOutputStream(IOUtil.newOutputStream(path + Predefine.BIN_EXT));\n            br.readLine();  // type\n            m.correctionConstant = Integer.parseInt(br.readLine());  // correctionConstant\n            out.writeInt(m.correctionConstant);\n            m.correctionParam = Double.parseDouble(br.readLine());  // getCorrectionParameter\n            out.writeDouble(m.correctionParam);\n            // label\n            int numOutcomes = Integer.parseInt(br.readLine());\n            out.writeInt(numOutcomes);\n            String[] outcomeLabels = new String[numOutcomes];\n            m.outcomeNames = outcomeLabels;\n            for (int i = 0; i < numOutcomes; i++)\n            {\n                outcomeLabels[i] = br.readLine();\n                TextUtility.writeString(outcomeLabels[i], out);\n            }\n            // pattern\n            int numOCTypes = Integer.parseInt(br.readLine());\n            out.writeInt(numOCTypes);\n            int[][] outcomePatterns = new int[numOCTypes][];\n            for (int i = 0; i < numOCTypes; i++)\n            {\n                StringTokenizer tok = new StringTokenizer(br.readLine(), \" \");\n                int[] infoInts = new int[tok.countTokens()];\n                out.writeInt(infoInts.length);\n                for (int j = 0; tok.hasMoreTokens(); j++)\n                {\n                    infoInts[j] = Integer.parseInt(tok.nextToken());\n                    out.writeInt(infoInts[j]);\n                }\n                outcomePatterns[i] = infoInts;\n            }\n            // feature\n            int NUM_PREDS = Integer.parseInt(br.readLine());\n            out.writeInt(NUM_PREDS);\n            String[] predLabels = new String[NUM_PREDS];\n            m.pmap = new DoubleArrayTrie<Integer>();\n            TreeMap<String, Integer> tmpMap = new TreeMap<String, Integer>();\n            for (int i = 0; i < NUM_PREDS; i++)\n            {\n                predLabels[i] = br.readLine();\n                assert !tmpMap.containsKey(predLabels[i]) : \"\u91cd\u590d\u7684\u952e\uff1a \" + predLabels[i] + \" \u8bf7\u4f7f\u7528 -Dfile.encoding=UTF-8 \u8bad\u7ec3\";\n                TextUtility.writeString(predLabels[i], out);\n                tmpMap.put(predLabels[i], i);\n            }\n            m.pmap.build(tmpMap);\n            for (Map.Entry<String, Integer> entry : tmpMap.entrySet())\n            {\n                out.writeInt(entry.getValue());\n            }\n            m.pmap.save(out);\n            // params\n            Context[] params = new Context[NUM_PREDS];\n            int pid = 0;\n            for (int i = 0; i < outcomePatterns.length; i++)\n            {\n                int[] outcomePattern = new int[outcomePatterns[i].length - 1];\n                for (int k = 1; k < outcomePatterns[i].length; k++)\n                {\n                    outcomePattern[k - 1] = outcomePatterns[i][k];\n                }\n                for (int j = 0; j < outcomePatterns[i][0]; j++)\n                {\n                    double[] contextParameters = new double[outcomePatterns[i].length - 1];\n                    for (int k = 1; k < outcomePatterns[i].length; k++)\n                    {\n                        contextParameters[k - 1] = Double.parseDouble(br.readLine());\n                        out.writeDouble(contextParameters[k - 1]);\n                    }\n                    params[pid] = new Context(outcomePattern, contextParameters);\n                    pid++;\n                }\n            }\n            // prior\n            m.prior = new UniformPrior();\n            m.prior.setLabels(outcomeLabels);\n            // eval\n            m.evalParams = new EvalParameters(params, m.correctionParam, m.correctionConstant, outcomeLabels.length);\n            out.close();\n        }\n        catch (Exception e)\n        {\n            logger.severe(\"\u4ece\" + path + \"\u52a0\u8f7d\u6700\u5927\u71b5\u6a21\u578b\u5931\u8d25\uff01\" + TextUtility.exceptionToString(e));\n            return null;\n        }\n        return m;\n    }", "code_tokens": ["public", "static", "MaxEntModel", "create", "(", "String", "path", ")", "{", "MaxEntModel", "m", "=", "new", "MaxEntModel", "(", ")", ";", "try", "{", "BufferedReader", "br", "=", "new", "BufferedReader", "(", "new", "InputStreamReader", "(", "IOUtil", ".", "newInputStream", "(", "path", ")", ",", "\"UTF-8\"", ")", ")", ";", "DataOutputStream", "out", "=", "new", "DataOutputStream", "(", "IOUtil", ".", "newOutputStream", "(", "path", "+", "Predefine", ".", "BIN_EXT", ")", ")", ";", "br", ".", "readLine", "(", ")", ";", "// type", "m", ".", "correctionConstant", "=", "Integer", ".", "parseInt", "(", "br", ".", "readLine", "(", ")", ")", ";", "// correctionConstant", "out", ".", "writeInt", "(", "m", ".", "correctionConstant", ")", ";", "m", ".", "correctionParam", "=", "Double", ".", "parseDouble", "(", "br", ".", "readLine", "(", ")", ")", ";", "// getCorrectionParameter", "out", ".", "writeDouble", "(", "m", ".", "correctionParam", ")", ";", "// label", "int", "numOutcomes", "=", "Integer", ".", "parseInt", "(", "br", ".", "readLine", "(", ")", ")", ";", "out", ".", "writeInt", "(", "numOutcomes", ")", ";", "String", "[", "]", "outcomeLabels", "=", "new", "String", "[", "numOutcomes", "]", ";", "m", ".", "outcomeNames", "=", "outcomeLabels", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "numOutcomes", ";", "i", "++", ")", "{", "outcomeLabels", "[", "i", "]", "=", "br", ".", "readLine", "(", ")", ";", "TextUtility", ".", "writeString", "(", "outcomeLabels", "[", "i", "]", ",", "out", ")", ";", "}", "// pattern", "int", "numOCTypes", "=", "Integer", ".", "parseInt", "(", "br", ".", "readLine", "(", ")", ")", ";", "out", ".", "writeInt", "(", "numOCTypes", ")", ";", "int", "[", "]", "[", "]", "outcomePatterns", "=", "new", "int", "[", "numOCTypes", "]", "[", "", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "numOCTypes", ";", "i", "++", ")", "{", "StringTokenizer", "tok", "=", "new", "StringTokenizer", "(", "br", ".", "readLine", "(", ")", ",", "\" \"", ")", ";", "int", "[", "]", "infoInts", "=", "new", "int", "[", "tok", ".", "countTokens", "(", ")", "]", ";", "out", ".", "writeInt", "(", "infoInts", ".", "length", ")", ";", "for", "(", "int", "j", "=", "0", ";", "tok", ".", "hasMoreTokens", "(", ")", ";", "j", "++", ")", "{", "infoInts", "[", "j", "]", "=", "Integer", ".", "parseInt", "(", "tok", ".", "nextToken", "(", ")", ")", ";", "out", ".", "writeInt", "(", "infoInts", "[", "j", "]", ")", ";", "}", "outcomePatterns", "[", "i", "]", "=", "infoInts", ";", "}", "// feature", "int", "NUM_PREDS", "=", "Integer", ".", "parseInt", "(", "br", ".", "readLine", "(", ")", ")", ";", "out", ".", "writeInt", "(", "NUM_PREDS", ")", ";", "String", "[", "]", "predLabels", "=", "new", "String", "[", "NUM_PREDS", "]", ";", "m", ".", "pmap", "=", "new", "DoubleArrayTrie", "<", "Integer", ">", "(", ")", ";", "TreeMap", "<", "String", ",", "Integer", ">", "tmpMap", "=", "new", "TreeMap", "<", "String", ",", "Integer", ">", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "NUM_PREDS", ";", "i", "++", ")", "{", "predLabels", "[", "i", "]", "=", "br", ".", "readLine", "(", ")", ";", "assert", "!", "tmpMap", ".", "containsKey", "(", "predLabels", "[", "i", "]", ")", ":", "\"\u91cd\u590d\u7684\u952e\uff1a \" + predLab", "l", "[i] + \" \u8bf7\u4f7f", "\u7528", " ", "-", "f", "le.encoding=UTF-8 \u8bad\u7ec3\";", "", "TextUtility", ".", "writeString", "(", "predLabels", "[", "i", "]", ",", "out", ")", ";", "tmpMap", ".", "put", "(", "predLabels", "[", "i", "]", ",", "i", ")", ";", "}", "m", ".", "pmap", ".", "build", "(", "tmpMap", ")", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "Integer", ">", "entry", ":", "tmpMap", ".", "entrySet", "(", ")", ")", "{", "out", ".", "writeInt", "(", "entry", ".", "getValue", "(", ")", ")", ";", "}", "m", ".", "pmap", ".", "save", "(", "out", ")", ";", "// params", "Context", "[", "]", "params", "=", "new", "Context", "[", "NUM_PREDS", "]", ";", "int", "pid", "=", "0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "outcomePatterns", ".", "length", ";", "i", "++", ")", "{", "int", "[", "]", "outcomePattern", "=", "new", "int", "[", "outcomePatterns", "[", "i", "]", ".", "length", "-", "1", "]", ";", "for", "(", "int", "k", "=", "1", ";", "k", "<", "outcomePatterns", "[", "i", "]", ".", "length", ";", "k", "++", ")", "{", "outcomePattern", "[", "k", "-", "1", "]", "=", "outcomePatterns", "[", "i", "]", "[", "k", "]", ";", "}", "for", "(", "int", "j", "=", "0", ";", "j", "<", "outcomePatterns", "[", "i", "]", "[", "0", "]", ";", "j", "++", ")", "{", "double", "[", "]", "contextParameters", "=", "new", "double", "[", "outcomePatterns", "[", "i", "]", ".", "length", "-", "1", "]", ";", "for", "(", "int", "k", "=", "1", ";", "k", "<", "outcomePatterns", "[", "i", "]", ".", "length", ";", "k", "++", ")", "{", "contextParameters", "[", "k", "-", "1", "]", "=", "Double", ".", "parseDouble", "(", "br", ".", "readLine", "(", ")", ")", ";", "out", ".", "writeDouble", "(", "contextParameters", "[", "k", "-", "1", "]", ")", ";", "}", "params", "[", "pid", "]", "=", "new", "Context", "(", "outcomePattern", ",", "contextParameters", ")", ";", "pid", "++", ";", "}", "}", "// prior", "m", ".", "prior", "=", "new", "UniformPrior", "(", ")", ";", "m", ".", "prior", ".", "setLabels", "(", "outcomeLabels", ")", ";", "// eval", "m", ".", "evalParams", "=", "new", "EvalParameters", "(", "params", ",", "m", ".", "correctionParam", ",", "m", ".", "correctionConstant", ",", "outcomeLabels", ".", "length", ")", ";", "out", ".", "close", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "logger", ".", "severe", "(", "\"\u4ece\" +", "p", "th +", "\"", "\u8f7d\u6700\u5927\u71b5\u6a21\u578b\u5931\u8d25\uff01\" + TextUtility.excepti", "n", "oString(e))", ";", "", "", "", "", "", "", "return", "null", ";", "}", "return", "m", ";", "}"], "original_string": "public static MaxEntModel create(String path)\n    {\n        MaxEntModel m = new MaxEntModel();\n        try\n        {\n            BufferedReader br = new BufferedReader(new InputStreamReader(IOUtil.newInputStream(path), \"UTF-8\"));\n            DataOutputStream out = new DataOutputStream(IOUtil.newOutputStream(path + Predefine.BIN_EXT));\n            br.readLine();  // type\n            m.correctionConstant = Integer.parseInt(br.readLine());  // correctionConstant\n            out.writeInt(m.correctionConstant);\n            m.correctionParam = Double.parseDouble(br.readLine());  // getCorrectionParameter\n            out.writeDouble(m.correctionParam);\n            // label\n            int numOutcomes = Integer.parseInt(br.readLine());\n            out.writeInt(numOutcomes);\n            String[] outcomeLabels = new String[numOutcomes];\n            m.outcomeNames = outcomeLabels;\n            for (int i = 0; i < numOutcomes; i++)\n            {\n                outcomeLabels[i] = br.readLine();\n                TextUtility.writeString(outcomeLabels[i], out);\n            }\n            // pattern\n            int numOCTypes = Integer.parseInt(br.readLine());\n            out.writeInt(numOCTypes);\n            int[][] outcomePatterns = new int[numOCTypes][];\n            for (int i = 0; i < numOCTypes; i++)\n            {\n                StringTokenizer tok = new StringTokenizer(br.readLine(), \" \");\n                int[] infoInts = new int[tok.countTokens()];\n                out.writeInt(infoInts.length);\n                for (int j = 0; tok.hasMoreTokens(); j++)\n                {\n                    infoInts[j] = Integer.parseInt(tok.nextToken());\n                    out.writeInt(infoInts[j]);\n                }\n                outcomePatterns[i] = infoInts;\n            }\n            // feature\n            int NUM_PREDS = Integer.parseInt(br.readLine());\n            out.writeInt(NUM_PREDS);\n            String[] predLabels = new String[NUM_PREDS];\n            m.pmap = new DoubleArrayTrie<Integer>();\n            TreeMap<String, Integer> tmpMap = new TreeMap<String, Integer>();\n            for (int i = 0; i < NUM_PREDS; i++)\n            {\n                predLabels[i] = br.readLine();\n                assert !tmpMap.containsKey(predLabels[i]) : \"\u91cd\u590d\u7684\u952e\uff1a \" + predLabels[i] + \" \u8bf7\u4f7f\u7528 -Dfile.encoding=UTF-8 \u8bad\u7ec3\";\n                TextUtility.writeString(predLabels[i], out);\n                tmpMap.put(predLabels[i], i);\n            }\n            m.pmap.build(tmpMap);\n            for (Map.Entry<String, Integer> entry : tmpMap.entrySet())\n            {\n                out.writeInt(entry.getValue());\n            }\n            m.pmap.save(out);\n            // params\n            Context[] params = new Context[NUM_PREDS];\n            int pid = 0;\n            for (int i = 0; i < outcomePatterns.length; i++)\n            {\n                int[] outcomePattern = new int[outcomePatterns[i].length - 1];\n                for (int k = 1; k < outcomePatterns[i].length; k++)\n                {\n                    outcomePattern[k - 1] = outcomePatterns[i][k];\n                }\n                for (int j = 0; j < outcomePatterns[i][0]; j++)\n                {\n                    double[] contextParameters = new double[outcomePatterns[i].length - 1];\n                    for (int k = 1; k < outcomePatterns[i].length; k++)\n                    {\n                        contextParameters[k - 1] = Double.parseDouble(br.readLine());\n                        out.writeDouble(contextParameters[k - 1]);\n                    }\n                    params[pid] = new Context(outcomePattern, contextParameters);\n                    pid++;\n                }\n            }\n            // prior\n            m.prior = new UniformPrior();\n            m.prior.setLabels(outcomeLabels);\n            // eval\n            m.evalParams = new EvalParameters(params, m.correctionParam, m.correctionConstant, outcomeLabels.length);\n            out.close();\n        }\n        catch (Exception e)\n        {\n            logger.severe(\"\u4ece\" + path + \"\u52a0\u8f7d\u6700\u5927\u71b5\u6a21\u578b\u5931\u8d25\uff01\" + TextUtility.exceptionToString(e));\n            return null;\n        }\n        return m;\n    }"}, {"code": "public Class<T> getT() {\n        Type subTyping = Types.getBaseClass(getClass(), Descriptor.class);\n        if (!(subTyping instanceof ParameterizedType)) {\n            throw new IllegalStateException(getClass()+\" doesn't extend Descriptor with a type parameter.\");\n        }\n        return Types.erasure(Types.getTypeArgument(subTyping, 0));\n    }", "code_tokens": ["public", "Class", "<", "T", ">", "getT", "(", ")", "{", "Type", "subTyping", "=", "Types", ".", "getBaseClass", "(", "getClass", "(", ")", ",", "Descriptor", ".", "class", ")", ";", "if", "(", "!", "(", "subTyping", "instanceof", "ParameterizedType", ")", ")", "{", "throw", "new", "IllegalStateException", "(", "getClass", "(", ")", "+", "\" doesn't extend Descriptor with a type parameter.\"", ")", ";", "}", "return", "Types", ".", "erasure", "(", "Types", ".", "getTypeArgument", "(", "subTyping", ",", "0", ")", ")", ";", "}"], "original_string": "public Class<T> getT() {\n        Type subTyping = Types.getBaseClass(getClass(), Descriptor.class);\n        if (!(subTyping instanceof ParameterizedType)) {\n            throw new IllegalStateException(getClass()+\" doesn't extend Descriptor with a type parameter.\");\n        }\n        return Types.erasure(Types.getTypeArgument(subTyping, 0));\n    }"}, {"code": "public final ListScanRunsPagedResponse listScanRuns(String parent) {\n    ListScanRunsRequest request = ListScanRunsRequest.newBuilder().setParent(parent).build();\n    return listScanRuns(request);\n  }", "code_tokens": ["public", "final", "ListScanRunsPagedResponse", "listScanRuns", "(", "String", "parent", ")", "{", "ListScanRunsRequest", "request", "=", "ListScanRunsRequest", ".", "newBuilder", "(", ")", ".", "setParent", "(", "parent", ")", ".", "build", "(", ")", ";", "return", "listScanRuns", "(", "request", ")", ";", "}"], "original_string": "public final ListScanRunsPagedResponse listScanRuns(String parent) {\n    ListScanRunsRequest request = ListScanRunsRequest.newBuilder().setParent(parent).build();\n    return listScanRuns(request);\n  }"}, {"code": "AutoBuffer call(AutoBuffer ab) {\n    int tnum = ab.getTask();\n    RPC<?> t = ab._h2o.taskGet(tnum);\n    // Forgotten task, but still must ACKACK\n    if( t == null ) return RPC.ackack(ab,tnum);\n    return t.response(ab); // Do the 2nd half of this task, includes ACKACK\n  }", "code_tokens": ["AutoBuffer", "call", "(", "AutoBuffer", "ab", ")", "{", "int", "tnum", "=", "ab", ".", "getTask", "(", ")", ";", "RPC", "<", "?", ">", "t", "=", "ab", ".", "_h2o", ".", "taskGet", "(", "tnum", ")", ";", "// Forgotten task, but still must ACKACK", "if", "(", "t", "==", "null", ")", "return", "RPC", ".", "ackack", "(", "ab", ",", "tnum", ")", ";", "return", "t", ".", "response", "(", "ab", ")", ";", "// Do the 2nd half of this task, includes ACKACK", "}"], "original_string": "AutoBuffer call(AutoBuffer ab) {\n    int tnum = ab.getTask();\n    RPC<?> t = ab._h2o.taskGet(tnum);\n    // Forgotten task, but still must ACKACK\n    if( t == null ) return RPC.ackack(ab,tnum);\n    return t.response(ab); // Do the 2nd half of this task, includes ACKACK\n  }"}, {"code": "private void initialize() {\r\n\t\tthis.setCursor(new java.awt.Cursor(java.awt.Cursor.WAIT_CURSOR));\r\n\t\tthis.setResizable(false);\r\n\t\tthis.setContentPane(getAboutPanel());\r\n\t\tthis.pack();\r\n\t\tcenterFrame();\r\n\t}", "code_tokens": ["private", "void", "initialize", "(", ")", "{", "this", ".", "setCursor", "(", "new", "java", ".", "awt", ".", "Cursor", "(", "java", ".", "awt", ".", "Cursor", ".", "WAIT_CURSOR", ")", ")", ";", "this", ".", "setResizable", "(", "false", ")", ";", "this", ".", "setContentPane", "(", "getAboutPanel", "(", ")", ")", ";", "this", ".", "pack", "(", ")", ";", "centerFrame", "(", ")", ";", "}"], "original_string": "private void initialize() {\r\n\t\tthis.setCursor(new java.awt.Cursor(java.awt.Cursor.WAIT_CURSOR));\r\n\t\tthis.setResizable(false);\r\n\t\tthis.setContentPane(getAboutPanel());\r\n\t\tthis.pack();\r\n\t\tcenterFrame();\r\n\t}"}, {"code": "public static Operation of(String id, String producer) {\n    return newBuilder(id, producer).build();\n  }", "code_tokens": ["public", "static", "Operation", "of", "(", "String", "id", ",", "String", "producer", ")", "{", "return", "newBuilder", "(", "id", ",", "producer", ")", ".", "build", "(", ")", ";", "}"], "original_string": "public static Operation of(String id, String producer) {\n    return newBuilder(id, producer).build();\n  }"}, {"code": "private InputStream getResourceStream(File file, String resourceName) {\n        try {\n            JarFile jarFile = (JarFile) jarFiles.get(file);\n            if (jarFile == null && file.isDirectory()) {\n                File resource = new File(file, resourceName);\n                if (resource.exists()) {\n                    return Files.newInputStream(resource.toPath());\n                }\n            } else {\n                if (jarFile == null) {\n                    if (file.exists()) {\n                        jarFile = new JarFile(file);\n                        jarFiles.put(file, jarFile);\n                    } else {\n                        return null;\n                    }\n                    //to eliminate a race condition, retrieve the entry\n                    //that is in the hash table under that filename\n                    jarFile = (JarFile) jarFiles.get(file);\n                }\n                JarEntry entry = jarFile.getJarEntry(resourceName);\n                if (entry != null) {\n                    return jarFile.getInputStream(entry);\n                }\n            }\n        } catch (Exception e) {\n            log(\"Ignoring Exception \" + e.getClass().getName() + \": \" + e.getMessage()\n                    + \" reading resource \" + resourceName + \" from \" + file, Project.MSG_VERBOSE);\n        }\n        return null;\n    }", "code_tokens": ["private", "InputStream", "getResourceStream", "(", "File", "file", ",", "String", "resourceName", ")", "{", "try", "{", "JarFile", "jarFile", "=", "(", "JarFile", ")", "jarFiles", ".", "get", "(", "file", ")", ";", "if", "(", "jarFile", "==", "null", "&&", "file", ".", "isDirectory", "(", ")", ")", "{", "File", "resource", "=", "new", "File", "(", "file", ",", "resourceName", ")", ";", "if", "(", "resource", ".", "exists", "(", ")", ")", "{", "return", "Files", ".", "newInputStream", "(", "resource", ".", "toPath", "(", ")", ")", ";", "}", "}", "else", "{", "if", "(", "jarFile", "==", "null", ")", "{", "if", "(", "file", ".", "exists", "(", ")", ")", "{", "jarFile", "=", "new", "JarFile", "(", "file", ")", ";", "jarFiles", ".", "put", "(", "file", ",", "jarFile", ")", ";", "}", "else", "{", "return", "null", ";", "}", "//to eliminate a race condition, retrieve the entry", "//that is in the hash table under that filename", "jarFile", "=", "(", "JarFile", ")", "jarFiles", ".", "get", "(", "file", ")", ";", "}", "JarEntry", "entry", "=", "jarFile", ".", "getJarEntry", "(", "resourceName", ")", ";", "if", "(", "entry", "!=", "null", ")", "{", "return", "jarFile", ".", "getInputStream", "(", "entry", ")", ";", "}", "}", "}", "catch", "(", "Exception", "e", ")", "{", "log", "(", "\"Ignoring Exception \"", "+", "e", ".", "getClass", "(", ")", ".", "getName", "(", ")", "+", "\": \"", "+", "e", ".", "getMessage", "(", ")", "+", "\" reading resource \"", "+", "resourceName", "+", "\" from \"", "+", "file", ",", "Project", ".", "MSG_VERBOSE", ")", ";", "}", "return", "null", ";", "}"], "original_string": "private InputStream getResourceStream(File file, String resourceName) {\n        try {\n            JarFile jarFile = (JarFile) jarFiles.get(file);\n            if (jarFile == null && file.isDirectory()) {\n                File resource = new File(file, resourceName);\n                if (resource.exists()) {\n                    return Files.newInputStream(resource.toPath());\n                }\n            } else {\n                if (jarFile == null) {\n                    if (file.exists()) {\n                        jarFile = new JarFile(file);\n                        jarFiles.put(file, jarFile);\n                    } else {\n                        return null;\n                    }\n                    //to eliminate a race condition, retrieve the entry\n                    //that is in the hash table under that filename\n                    jarFile = (JarFile) jarFiles.get(file);\n                }\n                JarEntry entry = jarFile.getJarEntry(resourceName);\n                if (entry != null) {\n                    return jarFile.getInputStream(entry);\n                }\n            }\n        } catch (Exception e) {\n            log(\"Ignoring Exception \" + e.getClass().getName() + \": \" + e.getMessage()\n                    + \" reading resource \" + resourceName + \" from \" + file, Project.MSG_VERBOSE);\n        }\n        return null;\n    }"}, {"code": "@SuppressWarnings(\"unchecked\")\n    private String encodeAttribute(String s, Charset charset) throws ErrorDataEncoderException {\n        if (s == null) {\n            return \"\";\n        }\n        try {\n            String encoded = URLEncoder.encode(s, charset.name());\n            if (encoderMode == EncoderMode.RFC3986) {\n                for (Map.Entry<Pattern, String> entry : percentEncodings) {\n                    String replacement = entry.getValue();\n                    encoded = entry.getKey().matcher(encoded).replaceAll(replacement);\n                }\n            }\n            return encoded;\n        } catch (UnsupportedEncodingException e) {\n            throw new ErrorDataEncoderException(charset.name(), e);\n        }\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "\"unchecked\"", ")", "private", "String", "encodeAttribute", "(", "String", "s", ",", "Charset", "charset", ")", "throws", "ErrorDataEncoderException", "{", "if", "(", "s", "==", "null", ")", "{", "return", "\"\"", ";", "}", "try", "{", "String", "encoded", "=", "URLEncoder", ".", "encode", "(", "s", ",", "charset", ".", "name", "(", ")", ")", ";", "if", "(", "encoderMode", "==", "EncoderMode", ".", "RFC3986", ")", "{", "for", "(", "Map", ".", "Entry", "<", "Pattern", ",", "String", ">", "entry", ":", "percentEncodings", ")", "{", "String", "replacement", "=", "entry", ".", "getValue", "(", ")", ";", "encoded", "=", "entry", ".", "getKey", "(", ")", ".", "matcher", "(", "encoded", ")", ".", "replaceAll", "(", "replacement", ")", ";", "}", "}", "return", "encoded", ";", "}", "catch", "(", "UnsupportedEncodingException", "e", ")", "{", "throw", "new", "ErrorDataEncoderException", "(", "charset", ".", "name", "(", ")", ",", "e", ")", ";", "}", "}"], "original_string": "@SuppressWarnings(\"unchecked\")\n    private String encodeAttribute(String s, Charset charset) throws ErrorDataEncoderException {\n        if (s == null) {\n            return \"\";\n        }\n        try {\n            String encoded = URLEncoder.encode(s, charset.name());\n            if (encoderMode == EncoderMode.RFC3986) {\n                for (Map.Entry<Pattern, String> entry : percentEncodings) {\n                    String replacement = entry.getValue();\n                    encoded = entry.getKey().matcher(encoded).replaceAll(replacement);\n                }\n            }\n            return encoded;\n        } catch (UnsupportedEncodingException e) {\n            throw new ErrorDataEncoderException(charset.name(), e);\n        }\n    }"}, {"code": "@Override\n    public Configuration getConfiguration() {\n        try {\n            globalLock.readLock().lock();\n            return configuration;\n        } finally {\n            globalLock.readLock().unlock();\n        }\n    }", "code_tokens": ["@", "Override", "public", "Configuration", "getConfiguration", "(", ")", "{", "try", "{", "globalLock", ".", "readLock", "(", ")", ".", "lock", "(", ")", ";", "return", "configuration", ";", "}", "finally", "{", "globalLock", ".", "readLock", "(", ")", ".", "unlock", "(", ")", ";", "}", "}"], "original_string": "@Override\n    public Configuration getConfiguration() {\n        try {\n            globalLock.readLock().lock();\n            return configuration;\n        } finally {\n            globalLock.readLock().unlock();\n        }\n    }"}, {"code": "public final AppProfile getAppProfile(String name) {\n\n    GetAppProfileRequest request = GetAppProfileRequest.newBuilder().setName(name).build();\n    return getAppProfile(request);\n  }", "code_tokens": ["public", "final", "AppProfile", "getAppProfile", "(", "String", "name", ")", "{", "GetAppProfileRequest", "request", "=", "GetAppProfileRequest", ".", "newBuilder", "(", ")", ".", "setName", "(", "name", ")", ".", "build", "(", ")", ";", "return", "getAppProfile", "(", "request", ")", ";", "}"], "original_string": "public final AppProfile getAppProfile(String name) {\n\n    GetAppProfileRequest request = GetAppProfileRequest.newBuilder().setName(name).build();\n    return getAppProfile(request);\n  }"}]